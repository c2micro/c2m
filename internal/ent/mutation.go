// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/c2micro/c2mshr/defaults"
	"github.com/c2micro/c2m/internal/ent/beacon"
	"github.com/c2micro/c2m/internal/ent/blobber"
	"github.com/c2micro/c2m/internal/ent/chat"
	"github.com/c2micro/c2m/internal/ent/credential"
	"github.com/c2micro/c2m/internal/ent/group"
	"github.com/c2micro/c2m/internal/ent/listener"
	"github.com/c2micro/c2m/internal/ent/message"
	"github.com/c2micro/c2m/internal/ent/operator"
	"github.com/c2micro/c2m/internal/ent/pki"
	"github.com/c2micro/c2m/internal/ent/predicate"
	"github.com/c2micro/c2m/internal/ent/task"
	"github.com/c2micro/c2m/internal/types"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBeacon     = "Beacon"
	TypeBlobber    = "Blobber"
	TypeChat       = "Chat"
	TypeCredential = "Credential"
	TypeGroup      = "Group"
	TypeListener   = "Listener"
	TypeMessage    = "Message"
	TypeOperator   = "Operator"
	TypePki        = "Pki"
	TypeTask       = "Task"
)

// BeaconMutation represents an operation that mutates the Beacon nodes in the graph.
type BeaconMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	bid             *uint32
	addbid          *int32
	ext_ip          *types.Inet
	int_ip          *types.Inet
	os              *defaults.BeaconOS
	os_meta         *string
	hostname        *string
	username        *string
	domain          *string
	privileged      *bool
	process_name    *string
	pid             *uint32
	addpid          *int32
	arch            *defaults.BeaconArch
	sleep           *uint32
	addsleep        *int32
	jitter          *uint8
	addjitter       *int8
	first           *time.Time
	last            *time.Time
	caps            *uint32
	addcaps         *int32
	note            *string
	color           *uint32
	addcolor        *int32
	clearedFields   map[string]struct{}
	listener        *int
	clearedlistener bool
	group           map[int]struct{}
	removedgroup    map[int]struct{}
	clearedgroup    bool
	task            map[int]struct{}
	removedtask     map[int]struct{}
	clearedtask     bool
	done            bool
	oldValue        func(context.Context) (*Beacon, error)
	predicates      []predicate.Beacon
}

var _ ent.Mutation = (*BeaconMutation)(nil)

// beaconOption allows management of the mutation configuration using functional options.
type beaconOption func(*BeaconMutation)

// newBeaconMutation creates new mutation for the Beacon entity.
func newBeaconMutation(c config, op Op, opts ...beaconOption) *BeaconMutation {
	m := &BeaconMutation{
		config:        c,
		op:            op,
		typ:           TypeBeacon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBeaconID sets the ID field of the mutation.
func withBeaconID(id int) beaconOption {
	return func(m *BeaconMutation) {
		var (
			err   error
			once  sync.Once
			value *Beacon
		)
		m.oldValue = func(ctx context.Context) (*Beacon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Beacon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBeacon sets the old Beacon of the mutation.
func withBeacon(node *Beacon) beaconOption {
	return func(m *BeaconMutation) {
		m.oldValue = func(context.Context) (*Beacon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BeaconMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BeaconMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BeaconMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BeaconMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Beacon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BeaconMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BeaconMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BeaconMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BeaconMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BeaconMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BeaconMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BeaconMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BeaconMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BeaconMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[beacon.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BeaconMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[beacon.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BeaconMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, beacon.FieldDeletedAt)
}

// SetBid sets the "bid" field.
func (m *BeaconMutation) SetBid(u uint32) {
	m.bid = &u
	m.addbid = nil
}

// Bid returns the value of the "bid" field in the mutation.
func (m *BeaconMutation) Bid() (r uint32, exists bool) {
	v := m.bid
	if v == nil {
		return
	}
	return *v, true
}

// OldBid returns the old "bid" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldBid(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBid: %w", err)
	}
	return oldValue.Bid, nil
}

// AddBid adds u to the "bid" field.
func (m *BeaconMutation) AddBid(u int32) {
	if m.addbid != nil {
		*m.addbid += u
	} else {
		m.addbid = &u
	}
}

// AddedBid returns the value that was added to the "bid" field in this mutation.
func (m *BeaconMutation) AddedBid() (r int32, exists bool) {
	v := m.addbid
	if v == nil {
		return
	}
	return *v, true
}

// ResetBid resets all changes to the "bid" field.
func (m *BeaconMutation) ResetBid() {
	m.bid = nil
	m.addbid = nil
}

// SetListenerID sets the "listener_id" field.
func (m *BeaconMutation) SetListenerID(i int) {
	m.listener = &i
}

// ListenerID returns the value of the "listener_id" field in the mutation.
func (m *BeaconMutation) ListenerID() (r int, exists bool) {
	v := m.listener
	if v == nil {
		return
	}
	return *v, true
}

// OldListenerID returns the old "listener_id" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldListenerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListenerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListenerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListenerID: %w", err)
	}
	return oldValue.ListenerID, nil
}

// ResetListenerID resets all changes to the "listener_id" field.
func (m *BeaconMutation) ResetListenerID() {
	m.listener = nil
}

// SetExtIP sets the "ext_ip" field.
func (m *BeaconMutation) SetExtIP(t types.Inet) {
	m.ext_ip = &t
}

// ExtIP returns the value of the "ext_ip" field in the mutation.
func (m *BeaconMutation) ExtIP() (r types.Inet, exists bool) {
	v := m.ext_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldExtIP returns the old "ext_ip" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldExtIP(ctx context.Context) (v types.Inet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtIP: %w", err)
	}
	return oldValue.ExtIP, nil
}

// ClearExtIP clears the value of the "ext_ip" field.
func (m *BeaconMutation) ClearExtIP() {
	m.ext_ip = nil
	m.clearedFields[beacon.FieldExtIP] = struct{}{}
}

// ExtIPCleared returns if the "ext_ip" field was cleared in this mutation.
func (m *BeaconMutation) ExtIPCleared() bool {
	_, ok := m.clearedFields[beacon.FieldExtIP]
	return ok
}

// ResetExtIP resets all changes to the "ext_ip" field.
func (m *BeaconMutation) ResetExtIP() {
	m.ext_ip = nil
	delete(m.clearedFields, beacon.FieldExtIP)
}

// SetIntIP sets the "int_ip" field.
func (m *BeaconMutation) SetIntIP(t types.Inet) {
	m.int_ip = &t
}

// IntIP returns the value of the "int_ip" field in the mutation.
func (m *BeaconMutation) IntIP() (r types.Inet, exists bool) {
	v := m.int_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIntIP returns the old "int_ip" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldIntIP(ctx context.Context) (v types.Inet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntIP: %w", err)
	}
	return oldValue.IntIP, nil
}

// ClearIntIP clears the value of the "int_ip" field.
func (m *BeaconMutation) ClearIntIP() {
	m.int_ip = nil
	m.clearedFields[beacon.FieldIntIP] = struct{}{}
}

// IntIPCleared returns if the "int_ip" field was cleared in this mutation.
func (m *BeaconMutation) IntIPCleared() bool {
	_, ok := m.clearedFields[beacon.FieldIntIP]
	return ok
}

// ResetIntIP resets all changes to the "int_ip" field.
func (m *BeaconMutation) ResetIntIP() {
	m.int_ip = nil
	delete(m.clearedFields, beacon.FieldIntIP)
}

// SetOs sets the "os" field.
func (m *BeaconMutation) SetOs(do defaults.BeaconOS) {
	m.os = &do
}

// Os returns the value of the "os" field in the mutation.
func (m *BeaconMutation) Os() (r defaults.BeaconOS, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldOs(ctx context.Context) (v defaults.BeaconOS, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *BeaconMutation) ResetOs() {
	m.os = nil
}

// SetOsMeta sets the "os_meta" field.
func (m *BeaconMutation) SetOsMeta(s string) {
	m.os_meta = &s
}

// OsMeta returns the value of the "os_meta" field in the mutation.
func (m *BeaconMutation) OsMeta() (r string, exists bool) {
	v := m.os_meta
	if v == nil {
		return
	}
	return *v, true
}

// OldOsMeta returns the old "os_meta" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldOsMeta(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsMeta: %w", err)
	}
	return oldValue.OsMeta, nil
}

// ClearOsMeta clears the value of the "os_meta" field.
func (m *BeaconMutation) ClearOsMeta() {
	m.os_meta = nil
	m.clearedFields[beacon.FieldOsMeta] = struct{}{}
}

// OsMetaCleared returns if the "os_meta" field was cleared in this mutation.
func (m *BeaconMutation) OsMetaCleared() bool {
	_, ok := m.clearedFields[beacon.FieldOsMeta]
	return ok
}

// ResetOsMeta resets all changes to the "os_meta" field.
func (m *BeaconMutation) ResetOsMeta() {
	m.os_meta = nil
	delete(m.clearedFields, beacon.FieldOsMeta)
}

// SetHostname sets the "hostname" field.
func (m *BeaconMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *BeaconMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ClearHostname clears the value of the "hostname" field.
func (m *BeaconMutation) ClearHostname() {
	m.hostname = nil
	m.clearedFields[beacon.FieldHostname] = struct{}{}
}

// HostnameCleared returns if the "hostname" field was cleared in this mutation.
func (m *BeaconMutation) HostnameCleared() bool {
	_, ok := m.clearedFields[beacon.FieldHostname]
	return ok
}

// ResetHostname resets all changes to the "hostname" field.
func (m *BeaconMutation) ResetHostname() {
	m.hostname = nil
	delete(m.clearedFields, beacon.FieldHostname)
}

// SetUsername sets the "username" field.
func (m *BeaconMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *BeaconMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *BeaconMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[beacon.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *BeaconMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[beacon.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *BeaconMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, beacon.FieldUsername)
}

// SetDomain sets the "domain" field.
func (m *BeaconMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *BeaconMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *BeaconMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[beacon.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *BeaconMutation) DomainCleared() bool {
	_, ok := m.clearedFields[beacon.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *BeaconMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, beacon.FieldDomain)
}

// SetPrivileged sets the "privileged" field.
func (m *BeaconMutation) SetPrivileged(b bool) {
	m.privileged = &b
}

// Privileged returns the value of the "privileged" field in the mutation.
func (m *BeaconMutation) Privileged() (r bool, exists bool) {
	v := m.privileged
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivileged returns the old "privileged" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldPrivileged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivileged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivileged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivileged: %w", err)
	}
	return oldValue.Privileged, nil
}

// ClearPrivileged clears the value of the "privileged" field.
func (m *BeaconMutation) ClearPrivileged() {
	m.privileged = nil
	m.clearedFields[beacon.FieldPrivileged] = struct{}{}
}

// PrivilegedCleared returns if the "privileged" field was cleared in this mutation.
func (m *BeaconMutation) PrivilegedCleared() bool {
	_, ok := m.clearedFields[beacon.FieldPrivileged]
	return ok
}

// ResetPrivileged resets all changes to the "privileged" field.
func (m *BeaconMutation) ResetPrivileged() {
	m.privileged = nil
	delete(m.clearedFields, beacon.FieldPrivileged)
}

// SetProcessName sets the "process_name" field.
func (m *BeaconMutation) SetProcessName(s string) {
	m.process_name = &s
}

// ProcessName returns the value of the "process_name" field in the mutation.
func (m *BeaconMutation) ProcessName() (r string, exists bool) {
	v := m.process_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessName returns the old "process_name" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldProcessName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessName: %w", err)
	}
	return oldValue.ProcessName, nil
}

// ClearProcessName clears the value of the "process_name" field.
func (m *BeaconMutation) ClearProcessName() {
	m.process_name = nil
	m.clearedFields[beacon.FieldProcessName] = struct{}{}
}

// ProcessNameCleared returns if the "process_name" field was cleared in this mutation.
func (m *BeaconMutation) ProcessNameCleared() bool {
	_, ok := m.clearedFields[beacon.FieldProcessName]
	return ok
}

// ResetProcessName resets all changes to the "process_name" field.
func (m *BeaconMutation) ResetProcessName() {
	m.process_name = nil
	delete(m.clearedFields, beacon.FieldProcessName)
}

// SetPid sets the "pid" field.
func (m *BeaconMutation) SetPid(u uint32) {
	m.pid = &u
	m.addpid = nil
}

// Pid returns the value of the "pid" field in the mutation.
func (m *BeaconMutation) Pid() (r uint32, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldPid(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// AddPid adds u to the "pid" field.
func (m *BeaconMutation) AddPid(u int32) {
	if m.addpid != nil {
		*m.addpid += u
	} else {
		m.addpid = &u
	}
}

// AddedPid returns the value that was added to the "pid" field in this mutation.
func (m *BeaconMutation) AddedPid() (r int32, exists bool) {
	v := m.addpid
	if v == nil {
		return
	}
	return *v, true
}

// ClearPid clears the value of the "pid" field.
func (m *BeaconMutation) ClearPid() {
	m.pid = nil
	m.addpid = nil
	m.clearedFields[beacon.FieldPid] = struct{}{}
}

// PidCleared returns if the "pid" field was cleared in this mutation.
func (m *BeaconMutation) PidCleared() bool {
	_, ok := m.clearedFields[beacon.FieldPid]
	return ok
}

// ResetPid resets all changes to the "pid" field.
func (m *BeaconMutation) ResetPid() {
	m.pid = nil
	m.addpid = nil
	delete(m.clearedFields, beacon.FieldPid)
}

// SetArch sets the "arch" field.
func (m *BeaconMutation) SetArch(da defaults.BeaconArch) {
	m.arch = &da
}

// Arch returns the value of the "arch" field in the mutation.
func (m *BeaconMutation) Arch() (r defaults.BeaconArch, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldArch(ctx context.Context) (v defaults.BeaconArch, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ResetArch resets all changes to the "arch" field.
func (m *BeaconMutation) ResetArch() {
	m.arch = nil
}

// SetSleep sets the "sleep" field.
func (m *BeaconMutation) SetSleep(u uint32) {
	m.sleep = &u
	m.addsleep = nil
}

// Sleep returns the value of the "sleep" field in the mutation.
func (m *BeaconMutation) Sleep() (r uint32, exists bool) {
	v := m.sleep
	if v == nil {
		return
	}
	return *v, true
}

// OldSleep returns the old "sleep" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldSleep(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSleep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSleep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSleep: %w", err)
	}
	return oldValue.Sleep, nil
}

// AddSleep adds u to the "sleep" field.
func (m *BeaconMutation) AddSleep(u int32) {
	if m.addsleep != nil {
		*m.addsleep += u
	} else {
		m.addsleep = &u
	}
}

// AddedSleep returns the value that was added to the "sleep" field in this mutation.
func (m *BeaconMutation) AddedSleep() (r int32, exists bool) {
	v := m.addsleep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSleep resets all changes to the "sleep" field.
func (m *BeaconMutation) ResetSleep() {
	m.sleep = nil
	m.addsleep = nil
}

// SetJitter sets the "jitter" field.
func (m *BeaconMutation) SetJitter(u uint8) {
	m.jitter = &u
	m.addjitter = nil
}

// Jitter returns the value of the "jitter" field in the mutation.
func (m *BeaconMutation) Jitter() (r uint8, exists bool) {
	v := m.jitter
	if v == nil {
		return
	}
	return *v, true
}

// OldJitter returns the old "jitter" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldJitter(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJitter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJitter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJitter: %w", err)
	}
	return oldValue.Jitter, nil
}

// AddJitter adds u to the "jitter" field.
func (m *BeaconMutation) AddJitter(u int8) {
	if m.addjitter != nil {
		*m.addjitter += u
	} else {
		m.addjitter = &u
	}
}

// AddedJitter returns the value that was added to the "jitter" field in this mutation.
func (m *BeaconMutation) AddedJitter() (r int8, exists bool) {
	v := m.addjitter
	if v == nil {
		return
	}
	return *v, true
}

// ResetJitter resets all changes to the "jitter" field.
func (m *BeaconMutation) ResetJitter() {
	m.jitter = nil
	m.addjitter = nil
}

// SetFirst sets the "first" field.
func (m *BeaconMutation) SetFirst(t time.Time) {
	m.first = &t
}

// First returns the value of the "first" field in the mutation.
func (m *BeaconMutation) First() (r time.Time, exists bool) {
	v := m.first
	if v == nil {
		return
	}
	return *v, true
}

// OldFirst returns the old "first" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldFirst(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirst: %w", err)
	}
	return oldValue.First, nil
}

// ResetFirst resets all changes to the "first" field.
func (m *BeaconMutation) ResetFirst() {
	m.first = nil
}

// SetLast sets the "last" field.
func (m *BeaconMutation) SetLast(t time.Time) {
	m.last = &t
}

// Last returns the value of the "last" field in the mutation.
func (m *BeaconMutation) Last() (r time.Time, exists bool) {
	v := m.last
	if v == nil {
		return
	}
	return *v, true
}

// OldLast returns the old "last" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast: %w", err)
	}
	return oldValue.Last, nil
}

// ResetLast resets all changes to the "last" field.
func (m *BeaconMutation) ResetLast() {
	m.last = nil
}

// SetCaps sets the "caps" field.
func (m *BeaconMutation) SetCaps(u uint32) {
	m.caps = &u
	m.addcaps = nil
}

// Caps returns the value of the "caps" field in the mutation.
func (m *BeaconMutation) Caps() (r uint32, exists bool) {
	v := m.caps
	if v == nil {
		return
	}
	return *v, true
}

// OldCaps returns the old "caps" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldCaps(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaps: %w", err)
	}
	return oldValue.Caps, nil
}

// AddCaps adds u to the "caps" field.
func (m *BeaconMutation) AddCaps(u int32) {
	if m.addcaps != nil {
		*m.addcaps += u
	} else {
		m.addcaps = &u
	}
}

// AddedCaps returns the value that was added to the "caps" field in this mutation.
func (m *BeaconMutation) AddedCaps() (r int32, exists bool) {
	v := m.addcaps
	if v == nil {
		return
	}
	return *v, true
}

// ResetCaps resets all changes to the "caps" field.
func (m *BeaconMutation) ResetCaps() {
	m.caps = nil
	m.addcaps = nil
}

// SetNote sets the "note" field.
func (m *BeaconMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *BeaconMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *BeaconMutation) ClearNote() {
	m.note = nil
	m.clearedFields[beacon.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *BeaconMutation) NoteCleared() bool {
	_, ok := m.clearedFields[beacon.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *BeaconMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, beacon.FieldNote)
}

// SetColor sets the "color" field.
func (m *BeaconMutation) SetColor(u uint32) {
	m.color = &u
	m.addcolor = nil
}

// Color returns the value of the "color" field in the mutation.
func (m *BeaconMutation) Color() (r uint32, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Beacon entity.
// If the Beacon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BeaconMutation) OldColor(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// AddColor adds u to the "color" field.
func (m *BeaconMutation) AddColor(u int32) {
	if m.addcolor != nil {
		*m.addcolor += u
	} else {
		m.addcolor = &u
	}
}

// AddedColor returns the value that was added to the "color" field in this mutation.
func (m *BeaconMutation) AddedColor() (r int32, exists bool) {
	v := m.addcolor
	if v == nil {
		return
	}
	return *v, true
}

// ResetColor resets all changes to the "color" field.
func (m *BeaconMutation) ResetColor() {
	m.color = nil
	m.addcolor = nil
}

// ClearListener clears the "listener" edge to the Listener entity.
func (m *BeaconMutation) ClearListener() {
	m.clearedlistener = true
	m.clearedFields[beacon.FieldListenerID] = struct{}{}
}

// ListenerCleared reports if the "listener" edge to the Listener entity was cleared.
func (m *BeaconMutation) ListenerCleared() bool {
	return m.clearedlistener
}

// ListenerIDs returns the "listener" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ListenerID instead. It exists only for internal usage by the builders.
func (m *BeaconMutation) ListenerIDs() (ids []int) {
	if id := m.listener; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetListener resets all changes to the "listener" edge.
func (m *BeaconMutation) ResetListener() {
	m.listener = nil
	m.clearedlistener = false
}

// AddGroupIDs adds the "group" edge to the Group entity by ids.
func (m *BeaconMutation) AddGroupIDs(ids ...int) {
	if m.group == nil {
		m.group = make(map[int]struct{})
	}
	for i := range ids {
		m.group[ids[i]] = struct{}{}
	}
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *BeaconMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *BeaconMutation) GroupCleared() bool {
	return m.clearedgroup
}

// RemoveGroupIDs removes the "group" edge to the Group entity by IDs.
func (m *BeaconMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroup == nil {
		m.removedgroup = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.group, ids[i])
		m.removedgroup[ids[i]] = struct{}{}
	}
}

// RemovedGroup returns the removed IDs of the "group" edge to the Group entity.
func (m *BeaconMutation) RemovedGroupIDs() (ids []int) {
	for id := range m.removedgroup {
		ids = append(ids, id)
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
func (m *BeaconMutation) GroupIDs() (ids []int) {
	for id := range m.group {
		ids = append(ids, id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *BeaconMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
	m.removedgroup = nil
}

// AddTaskIDs adds the "task" edge to the Task entity by ids.
func (m *BeaconMutation) AddTaskIDs(ids ...int) {
	if m.task == nil {
		m.task = make(map[int]struct{})
	}
	for i := range ids {
		m.task[ids[i]] = struct{}{}
	}
}

// ClearTask clears the "task" edge to the Task entity.
func (m *BeaconMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *BeaconMutation) TaskCleared() bool {
	return m.clearedtask
}

// RemoveTaskIDs removes the "task" edge to the Task entity by IDs.
func (m *BeaconMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtask == nil {
		m.removedtask = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.task, ids[i])
		m.removedtask[ids[i]] = struct{}{}
	}
}

// RemovedTask returns the removed IDs of the "task" edge to the Task entity.
func (m *BeaconMutation) RemovedTaskIDs() (ids []int) {
	for id := range m.removedtask {
		ids = append(ids, id)
	}
	return
}

// TaskIDs returns the "task" edge IDs in the mutation.
func (m *BeaconMutation) TaskIDs() (ids []int) {
	for id := range m.task {
		ids = append(ids, id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *BeaconMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
	m.removedtask = nil
}

// Where appends a list predicates to the BeaconMutation builder.
func (m *BeaconMutation) Where(ps ...predicate.Beacon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BeaconMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BeaconMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Beacon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BeaconMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BeaconMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Beacon).
func (m *BeaconMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BeaconMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, beacon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, beacon.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, beacon.FieldDeletedAt)
	}
	if m.bid != nil {
		fields = append(fields, beacon.FieldBid)
	}
	if m.listener != nil {
		fields = append(fields, beacon.FieldListenerID)
	}
	if m.ext_ip != nil {
		fields = append(fields, beacon.FieldExtIP)
	}
	if m.int_ip != nil {
		fields = append(fields, beacon.FieldIntIP)
	}
	if m.os != nil {
		fields = append(fields, beacon.FieldOs)
	}
	if m.os_meta != nil {
		fields = append(fields, beacon.FieldOsMeta)
	}
	if m.hostname != nil {
		fields = append(fields, beacon.FieldHostname)
	}
	if m.username != nil {
		fields = append(fields, beacon.FieldUsername)
	}
	if m.domain != nil {
		fields = append(fields, beacon.FieldDomain)
	}
	if m.privileged != nil {
		fields = append(fields, beacon.FieldPrivileged)
	}
	if m.process_name != nil {
		fields = append(fields, beacon.FieldProcessName)
	}
	if m.pid != nil {
		fields = append(fields, beacon.FieldPid)
	}
	if m.arch != nil {
		fields = append(fields, beacon.FieldArch)
	}
	if m.sleep != nil {
		fields = append(fields, beacon.FieldSleep)
	}
	if m.jitter != nil {
		fields = append(fields, beacon.FieldJitter)
	}
	if m.first != nil {
		fields = append(fields, beacon.FieldFirst)
	}
	if m.last != nil {
		fields = append(fields, beacon.FieldLast)
	}
	if m.caps != nil {
		fields = append(fields, beacon.FieldCaps)
	}
	if m.note != nil {
		fields = append(fields, beacon.FieldNote)
	}
	if m.color != nil {
		fields = append(fields, beacon.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BeaconMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case beacon.FieldCreatedAt:
		return m.CreatedAt()
	case beacon.FieldUpdatedAt:
		return m.UpdatedAt()
	case beacon.FieldDeletedAt:
		return m.DeletedAt()
	case beacon.FieldBid:
		return m.Bid()
	case beacon.FieldListenerID:
		return m.ListenerID()
	case beacon.FieldExtIP:
		return m.ExtIP()
	case beacon.FieldIntIP:
		return m.IntIP()
	case beacon.FieldOs:
		return m.Os()
	case beacon.FieldOsMeta:
		return m.OsMeta()
	case beacon.FieldHostname:
		return m.Hostname()
	case beacon.FieldUsername:
		return m.Username()
	case beacon.FieldDomain:
		return m.Domain()
	case beacon.FieldPrivileged:
		return m.Privileged()
	case beacon.FieldProcessName:
		return m.ProcessName()
	case beacon.FieldPid:
		return m.Pid()
	case beacon.FieldArch:
		return m.Arch()
	case beacon.FieldSleep:
		return m.Sleep()
	case beacon.FieldJitter:
		return m.Jitter()
	case beacon.FieldFirst:
		return m.First()
	case beacon.FieldLast:
		return m.Last()
	case beacon.FieldCaps:
		return m.Caps()
	case beacon.FieldNote:
		return m.Note()
	case beacon.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BeaconMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case beacon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case beacon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case beacon.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case beacon.FieldBid:
		return m.OldBid(ctx)
	case beacon.FieldListenerID:
		return m.OldListenerID(ctx)
	case beacon.FieldExtIP:
		return m.OldExtIP(ctx)
	case beacon.FieldIntIP:
		return m.OldIntIP(ctx)
	case beacon.FieldOs:
		return m.OldOs(ctx)
	case beacon.FieldOsMeta:
		return m.OldOsMeta(ctx)
	case beacon.FieldHostname:
		return m.OldHostname(ctx)
	case beacon.FieldUsername:
		return m.OldUsername(ctx)
	case beacon.FieldDomain:
		return m.OldDomain(ctx)
	case beacon.FieldPrivileged:
		return m.OldPrivileged(ctx)
	case beacon.FieldProcessName:
		return m.OldProcessName(ctx)
	case beacon.FieldPid:
		return m.OldPid(ctx)
	case beacon.FieldArch:
		return m.OldArch(ctx)
	case beacon.FieldSleep:
		return m.OldSleep(ctx)
	case beacon.FieldJitter:
		return m.OldJitter(ctx)
	case beacon.FieldFirst:
		return m.OldFirst(ctx)
	case beacon.FieldLast:
		return m.OldLast(ctx)
	case beacon.FieldCaps:
		return m.OldCaps(ctx)
	case beacon.FieldNote:
		return m.OldNote(ctx)
	case beacon.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Beacon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BeaconMutation) SetField(name string, value ent.Value) error {
	switch name {
	case beacon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case beacon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case beacon.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case beacon.FieldBid:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBid(v)
		return nil
	case beacon.FieldListenerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListenerID(v)
		return nil
	case beacon.FieldExtIP:
		v, ok := value.(types.Inet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtIP(v)
		return nil
	case beacon.FieldIntIP:
		v, ok := value.(types.Inet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntIP(v)
		return nil
	case beacon.FieldOs:
		v, ok := value.(defaults.BeaconOS)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case beacon.FieldOsMeta:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsMeta(v)
		return nil
	case beacon.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case beacon.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case beacon.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case beacon.FieldPrivileged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivileged(v)
		return nil
	case beacon.FieldProcessName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessName(v)
		return nil
	case beacon.FieldPid:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case beacon.FieldArch:
		v, ok := value.(defaults.BeaconArch)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case beacon.FieldSleep:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSleep(v)
		return nil
	case beacon.FieldJitter:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJitter(v)
		return nil
	case beacon.FieldFirst:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirst(v)
		return nil
	case beacon.FieldLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast(v)
		return nil
	case beacon.FieldCaps:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaps(v)
		return nil
	case beacon.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case beacon.FieldColor:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Beacon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BeaconMutation) AddedFields() []string {
	var fields []string
	if m.addbid != nil {
		fields = append(fields, beacon.FieldBid)
	}
	if m.addpid != nil {
		fields = append(fields, beacon.FieldPid)
	}
	if m.addsleep != nil {
		fields = append(fields, beacon.FieldSleep)
	}
	if m.addjitter != nil {
		fields = append(fields, beacon.FieldJitter)
	}
	if m.addcaps != nil {
		fields = append(fields, beacon.FieldCaps)
	}
	if m.addcolor != nil {
		fields = append(fields, beacon.FieldColor)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BeaconMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case beacon.FieldBid:
		return m.AddedBid()
	case beacon.FieldPid:
		return m.AddedPid()
	case beacon.FieldSleep:
		return m.AddedSleep()
	case beacon.FieldJitter:
		return m.AddedJitter()
	case beacon.FieldCaps:
		return m.AddedCaps()
	case beacon.FieldColor:
		return m.AddedColor()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BeaconMutation) AddField(name string, value ent.Value) error {
	switch name {
	case beacon.FieldBid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBid(v)
		return nil
	case beacon.FieldPid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPid(v)
		return nil
	case beacon.FieldSleep:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSleep(v)
		return nil
	case beacon.FieldJitter:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJitter(v)
		return nil
	case beacon.FieldCaps:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCaps(v)
		return nil
	case beacon.FieldColor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColor(v)
		return nil
	}
	return fmt.Errorf("unknown Beacon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BeaconMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(beacon.FieldDeletedAt) {
		fields = append(fields, beacon.FieldDeletedAt)
	}
	if m.FieldCleared(beacon.FieldExtIP) {
		fields = append(fields, beacon.FieldExtIP)
	}
	if m.FieldCleared(beacon.FieldIntIP) {
		fields = append(fields, beacon.FieldIntIP)
	}
	if m.FieldCleared(beacon.FieldOsMeta) {
		fields = append(fields, beacon.FieldOsMeta)
	}
	if m.FieldCleared(beacon.FieldHostname) {
		fields = append(fields, beacon.FieldHostname)
	}
	if m.FieldCleared(beacon.FieldUsername) {
		fields = append(fields, beacon.FieldUsername)
	}
	if m.FieldCleared(beacon.FieldDomain) {
		fields = append(fields, beacon.FieldDomain)
	}
	if m.FieldCleared(beacon.FieldPrivileged) {
		fields = append(fields, beacon.FieldPrivileged)
	}
	if m.FieldCleared(beacon.FieldProcessName) {
		fields = append(fields, beacon.FieldProcessName)
	}
	if m.FieldCleared(beacon.FieldPid) {
		fields = append(fields, beacon.FieldPid)
	}
	if m.FieldCleared(beacon.FieldNote) {
		fields = append(fields, beacon.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BeaconMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BeaconMutation) ClearField(name string) error {
	switch name {
	case beacon.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case beacon.FieldExtIP:
		m.ClearExtIP()
		return nil
	case beacon.FieldIntIP:
		m.ClearIntIP()
		return nil
	case beacon.FieldOsMeta:
		m.ClearOsMeta()
		return nil
	case beacon.FieldHostname:
		m.ClearHostname()
		return nil
	case beacon.FieldUsername:
		m.ClearUsername()
		return nil
	case beacon.FieldDomain:
		m.ClearDomain()
		return nil
	case beacon.FieldPrivileged:
		m.ClearPrivileged()
		return nil
	case beacon.FieldProcessName:
		m.ClearProcessName()
		return nil
	case beacon.FieldPid:
		m.ClearPid()
		return nil
	case beacon.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Beacon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BeaconMutation) ResetField(name string) error {
	switch name {
	case beacon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case beacon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case beacon.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case beacon.FieldBid:
		m.ResetBid()
		return nil
	case beacon.FieldListenerID:
		m.ResetListenerID()
		return nil
	case beacon.FieldExtIP:
		m.ResetExtIP()
		return nil
	case beacon.FieldIntIP:
		m.ResetIntIP()
		return nil
	case beacon.FieldOs:
		m.ResetOs()
		return nil
	case beacon.FieldOsMeta:
		m.ResetOsMeta()
		return nil
	case beacon.FieldHostname:
		m.ResetHostname()
		return nil
	case beacon.FieldUsername:
		m.ResetUsername()
		return nil
	case beacon.FieldDomain:
		m.ResetDomain()
		return nil
	case beacon.FieldPrivileged:
		m.ResetPrivileged()
		return nil
	case beacon.FieldProcessName:
		m.ResetProcessName()
		return nil
	case beacon.FieldPid:
		m.ResetPid()
		return nil
	case beacon.FieldArch:
		m.ResetArch()
		return nil
	case beacon.FieldSleep:
		m.ResetSleep()
		return nil
	case beacon.FieldJitter:
		m.ResetJitter()
		return nil
	case beacon.FieldFirst:
		m.ResetFirst()
		return nil
	case beacon.FieldLast:
		m.ResetLast()
		return nil
	case beacon.FieldCaps:
		m.ResetCaps()
		return nil
	case beacon.FieldNote:
		m.ResetNote()
		return nil
	case beacon.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Beacon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BeaconMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.listener != nil {
		edges = append(edges, beacon.EdgeListener)
	}
	if m.group != nil {
		edges = append(edges, beacon.EdgeGroup)
	}
	if m.task != nil {
		edges = append(edges, beacon.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BeaconMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case beacon.EdgeListener:
		if id := m.listener; id != nil {
			return []ent.Value{*id}
		}
	case beacon.EdgeGroup:
		ids := make([]ent.Value, 0, len(m.group))
		for id := range m.group {
			ids = append(ids, id)
		}
		return ids
	case beacon.EdgeTask:
		ids := make([]ent.Value, 0, len(m.task))
		for id := range m.task {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BeaconMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgroup != nil {
		edges = append(edges, beacon.EdgeGroup)
	}
	if m.removedtask != nil {
		edges = append(edges, beacon.EdgeTask)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BeaconMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case beacon.EdgeGroup:
		ids := make([]ent.Value, 0, len(m.removedgroup))
		for id := range m.removedgroup {
			ids = append(ids, id)
		}
		return ids
	case beacon.EdgeTask:
		ids := make([]ent.Value, 0, len(m.removedtask))
		for id := range m.removedtask {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BeaconMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedlistener {
		edges = append(edges, beacon.EdgeListener)
	}
	if m.clearedgroup {
		edges = append(edges, beacon.EdgeGroup)
	}
	if m.clearedtask {
		edges = append(edges, beacon.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BeaconMutation) EdgeCleared(name string) bool {
	switch name {
	case beacon.EdgeListener:
		return m.clearedlistener
	case beacon.EdgeGroup:
		return m.clearedgroup
	case beacon.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BeaconMutation) ClearEdge(name string) error {
	switch name {
	case beacon.EdgeListener:
		m.ClearListener()
		return nil
	}
	return fmt.Errorf("unknown Beacon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BeaconMutation) ResetEdge(name string) error {
	switch name {
	case beacon.EdgeListener:
		m.ResetListener()
		return nil
	case beacon.EdgeGroup:
		m.ResetGroup()
		return nil
	case beacon.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown Beacon edge %s", name)
}

// BlobberMutation represents an operation that mutates the Blobber nodes in the graph.
type BlobberMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	hash               *[]byte
	blob               *[]byte
	size               *int
	addsize            *int
	clearedFields      map[string]struct{}
	task_args          map[int]struct{}
	removedtask_args   map[int]struct{}
	clearedtask_args   bool
	task_output        map[int]struct{}
	removedtask_output map[int]struct{}
	clearedtask_output bool
	done               bool
	oldValue           func(context.Context) (*Blobber, error)
	predicates         []predicate.Blobber
}

var _ ent.Mutation = (*BlobberMutation)(nil)

// blobberOption allows management of the mutation configuration using functional options.
type blobberOption func(*BlobberMutation)

// newBlobberMutation creates new mutation for the Blobber entity.
func newBlobberMutation(c config, op Op, opts ...blobberOption) *BlobberMutation {
	m := &BlobberMutation{
		config:        c,
		op:            op,
		typ:           TypeBlobber,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlobberID sets the ID field of the mutation.
func withBlobberID(id int) blobberOption {
	return func(m *BlobberMutation) {
		var (
			err   error
			once  sync.Once
			value *Blobber
		)
		m.oldValue = func(ctx context.Context) (*Blobber, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blobber.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlobber sets the old Blobber of the mutation.
func withBlobber(node *Blobber) blobberOption {
	return func(m *BlobberMutation) {
		m.oldValue = func(context.Context) (*Blobber, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlobberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlobberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlobberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlobberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blobber.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlobberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlobberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlobberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlobberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlobberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlobberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlobberMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlobberMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BlobberMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[blobber.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BlobberMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[blobber.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlobberMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, blobber.FieldDeletedAt)
}

// SetHash sets the "hash" field.
func (m *BlobberMutation) SetHash(b []byte) {
	m.hash = &b
}

// Hash returns the value of the "hash" field in the mutation.
func (m *BlobberMutation) Hash() (r []byte, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *BlobberMutation) ResetHash() {
	m.hash = nil
}

// SetBlob sets the "blob" field.
func (m *BlobberMutation) SetBlob(b []byte) {
	m.blob = &b
}

// Blob returns the value of the "blob" field in the mutation.
func (m *BlobberMutation) Blob() (r []byte, exists bool) {
	v := m.blob
	if v == nil {
		return
	}
	return *v, true
}

// OldBlob returns the old "blob" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldBlob(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlob: %w", err)
	}
	return oldValue.Blob, nil
}

// ResetBlob resets all changes to the "blob" field.
func (m *BlobberMutation) ResetBlob() {
	m.blob = nil
}

// SetSize sets the "size" field.
func (m *BlobberMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *BlobberMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *BlobberMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *BlobberMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *BlobberMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// AddTaskArgIDs adds the "task_args" edge to the Task entity by ids.
func (m *BlobberMutation) AddTaskArgIDs(ids ...int) {
	if m.task_args == nil {
		m.task_args = make(map[int]struct{})
	}
	for i := range ids {
		m.task_args[ids[i]] = struct{}{}
	}
}

// ClearTaskArgs clears the "task_args" edge to the Task entity.
func (m *BlobberMutation) ClearTaskArgs() {
	m.clearedtask_args = true
}

// TaskArgsCleared reports if the "task_args" edge to the Task entity was cleared.
func (m *BlobberMutation) TaskArgsCleared() bool {
	return m.clearedtask_args
}

// RemoveTaskArgIDs removes the "task_args" edge to the Task entity by IDs.
func (m *BlobberMutation) RemoveTaskArgIDs(ids ...int) {
	if m.removedtask_args == nil {
		m.removedtask_args = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.task_args, ids[i])
		m.removedtask_args[ids[i]] = struct{}{}
	}
}

// RemovedTaskArgs returns the removed IDs of the "task_args" edge to the Task entity.
func (m *BlobberMutation) RemovedTaskArgsIDs() (ids []int) {
	for id := range m.removedtask_args {
		ids = append(ids, id)
	}
	return
}

// TaskArgsIDs returns the "task_args" edge IDs in the mutation.
func (m *BlobberMutation) TaskArgsIDs() (ids []int) {
	for id := range m.task_args {
		ids = append(ids, id)
	}
	return
}

// ResetTaskArgs resets all changes to the "task_args" edge.
func (m *BlobberMutation) ResetTaskArgs() {
	m.task_args = nil
	m.clearedtask_args = false
	m.removedtask_args = nil
}

// AddTaskOutputIDs adds the "task_output" edge to the Task entity by ids.
func (m *BlobberMutation) AddTaskOutputIDs(ids ...int) {
	if m.task_output == nil {
		m.task_output = make(map[int]struct{})
	}
	for i := range ids {
		m.task_output[ids[i]] = struct{}{}
	}
}

// ClearTaskOutput clears the "task_output" edge to the Task entity.
func (m *BlobberMutation) ClearTaskOutput() {
	m.clearedtask_output = true
}

// TaskOutputCleared reports if the "task_output" edge to the Task entity was cleared.
func (m *BlobberMutation) TaskOutputCleared() bool {
	return m.clearedtask_output
}

// RemoveTaskOutputIDs removes the "task_output" edge to the Task entity by IDs.
func (m *BlobberMutation) RemoveTaskOutputIDs(ids ...int) {
	if m.removedtask_output == nil {
		m.removedtask_output = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.task_output, ids[i])
		m.removedtask_output[ids[i]] = struct{}{}
	}
}

// RemovedTaskOutput returns the removed IDs of the "task_output" edge to the Task entity.
func (m *BlobberMutation) RemovedTaskOutputIDs() (ids []int) {
	for id := range m.removedtask_output {
		ids = append(ids, id)
	}
	return
}

// TaskOutputIDs returns the "task_output" edge IDs in the mutation.
func (m *BlobberMutation) TaskOutputIDs() (ids []int) {
	for id := range m.task_output {
		ids = append(ids, id)
	}
	return
}

// ResetTaskOutput resets all changes to the "task_output" edge.
func (m *BlobberMutation) ResetTaskOutput() {
	m.task_output = nil
	m.clearedtask_output = false
	m.removedtask_output = nil
}

// Where appends a list predicates to the BlobberMutation builder.
func (m *BlobberMutation) Where(ps ...predicate.Blobber) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlobberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlobberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blobber, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlobberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlobberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blobber).
func (m *BlobberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlobberMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, blobber.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blobber.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, blobber.FieldDeletedAt)
	}
	if m.hash != nil {
		fields = append(fields, blobber.FieldHash)
	}
	if m.blob != nil {
		fields = append(fields, blobber.FieldBlob)
	}
	if m.size != nil {
		fields = append(fields, blobber.FieldSize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlobberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blobber.FieldCreatedAt:
		return m.CreatedAt()
	case blobber.FieldUpdatedAt:
		return m.UpdatedAt()
	case blobber.FieldDeletedAt:
		return m.DeletedAt()
	case blobber.FieldHash:
		return m.Hash()
	case blobber.FieldBlob:
		return m.Blob()
	case blobber.FieldSize:
		return m.Size()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlobberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blobber.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blobber.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blobber.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blobber.FieldHash:
		return m.OldHash(ctx)
	case blobber.FieldBlob:
		return m.OldBlob(ctx)
	case blobber.FieldSize:
		return m.OldSize(ctx)
	}
	return nil, fmt.Errorf("unknown Blobber field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlobberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blobber.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blobber.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blobber.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blobber.FieldHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case blobber.FieldBlob:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlob(v)
		return nil
	case blobber.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	}
	return fmt.Errorf("unknown Blobber field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlobberMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, blobber.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlobberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blobber.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlobberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blobber.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Blobber numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlobberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blobber.FieldDeletedAt) {
		fields = append(fields, blobber.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlobberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlobberMutation) ClearField(name string) error {
	switch name {
	case blobber.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Blobber nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlobberMutation) ResetField(name string) error {
	switch name {
	case blobber.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blobber.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blobber.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blobber.FieldHash:
		m.ResetHash()
		return nil
	case blobber.FieldBlob:
		m.ResetBlob()
		return nil
	case blobber.FieldSize:
		m.ResetSize()
		return nil
	}
	return fmt.Errorf("unknown Blobber field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlobberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task_args != nil {
		edges = append(edges, blobber.EdgeTaskArgs)
	}
	if m.task_output != nil {
		edges = append(edges, blobber.EdgeTaskOutput)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlobberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blobber.EdgeTaskArgs:
		ids := make([]ent.Value, 0, len(m.task_args))
		for id := range m.task_args {
			ids = append(ids, id)
		}
		return ids
	case blobber.EdgeTaskOutput:
		ids := make([]ent.Value, 0, len(m.task_output))
		for id := range m.task_output {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlobberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtask_args != nil {
		edges = append(edges, blobber.EdgeTaskArgs)
	}
	if m.removedtask_output != nil {
		edges = append(edges, blobber.EdgeTaskOutput)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlobberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blobber.EdgeTaskArgs:
		ids := make([]ent.Value, 0, len(m.removedtask_args))
		for id := range m.removedtask_args {
			ids = append(ids, id)
		}
		return ids
	case blobber.EdgeTaskOutput:
		ids := make([]ent.Value, 0, len(m.removedtask_output))
		for id := range m.removedtask_output {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlobberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask_args {
		edges = append(edges, blobber.EdgeTaskArgs)
	}
	if m.clearedtask_output {
		edges = append(edges, blobber.EdgeTaskOutput)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlobberMutation) EdgeCleared(name string) bool {
	switch name {
	case blobber.EdgeTaskArgs:
		return m.clearedtask_args
	case blobber.EdgeTaskOutput:
		return m.clearedtask_output
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlobberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Blobber unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlobberMutation) ResetEdge(name string) error {
	switch name {
	case blobber.EdgeTaskArgs:
		m.ResetTaskArgs()
		return nil
	case blobber.EdgeTaskOutput:
		m.ResetTaskOutput()
		return nil
	}
	return fmt.Errorf("unknown Blobber edge %s", name)
}

// ChatMutation represents an operation that mutates the Chat nodes in the graph.
type ChatMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	message         *string
	clearedFields   map[string]struct{}
	operator        *int
	clearedoperator bool
	done            bool
	oldValue        func(context.Context) (*Chat, error)
	predicates      []predicate.Chat
}

var _ ent.Mutation = (*ChatMutation)(nil)

// chatOption allows management of the mutation configuration using functional options.
type chatOption func(*ChatMutation)

// newChatMutation creates new mutation for the Chat entity.
func newChatMutation(c config, op Op, opts ...chatOption) *ChatMutation {
	m := &ChatMutation{
		config:        c,
		op:            op,
		typ:           TypeChat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChatID sets the ID field of the mutation.
func withChatID(id int) chatOption {
	return func(m *ChatMutation) {
		var (
			err   error
			once  sync.Once
			value *Chat
		)
		m.oldValue = func(ctx context.Context) (*Chat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChat sets the old Chat of the mutation.
func withChat(node *Chat) chatOption {
	return func(m *ChatMutation) {
		m.oldValue = func(context.Context) (*Chat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFrom sets the "from" field.
func (m *ChatMutation) SetFrom(i int) {
	m.operator = &i
}

// From returns the value of the "from" field in the mutation.
func (m *ChatMutation) From() (r int, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldFrom(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ClearFrom clears the value of the "from" field.
func (m *ChatMutation) ClearFrom() {
	m.operator = nil
	m.clearedFields[chat.FieldFrom] = struct{}{}
}

// FromCleared returns if the "from" field was cleared in this mutation.
func (m *ChatMutation) FromCleared() bool {
	_, ok := m.clearedFields[chat.FieldFrom]
	return ok
}

// ResetFrom resets all changes to the "from" field.
func (m *ChatMutation) ResetFrom() {
	m.operator = nil
	delete(m.clearedFields, chat.FieldFrom)
}

// SetMessage sets the "message" field.
func (m *ChatMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ChatMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *ChatMutation) ResetMessage() {
	m.message = nil
}

// SetOperatorID sets the "operator" edge to the Operator entity by id.
func (m *ChatMutation) SetOperatorID(id int) {
	m.operator = &id
}

// ClearOperator clears the "operator" edge to the Operator entity.
func (m *ChatMutation) ClearOperator() {
	m.clearedoperator = true
	m.clearedFields[chat.FieldFrom] = struct{}{}
}

// OperatorCleared reports if the "operator" edge to the Operator entity was cleared.
func (m *ChatMutation) OperatorCleared() bool {
	return m.FromCleared() || m.clearedoperator
}

// OperatorID returns the "operator" edge ID in the mutation.
func (m *ChatMutation) OperatorID() (id int, exists bool) {
	if m.operator != nil {
		return *m.operator, true
	}
	return
}

// OperatorIDs returns the "operator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OperatorID instead. It exists only for internal usage by the builders.
func (m *ChatMutation) OperatorIDs() (ids []int) {
	if id := m.operator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperator resets all changes to the "operator" edge.
func (m *ChatMutation) ResetOperator() {
	m.operator = nil
	m.clearedoperator = false
}

// Where appends a list predicates to the ChatMutation builder.
func (m *ChatMutation) Where(ps ...predicate.Chat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chat).
func (m *ChatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChatMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, chat.FieldCreatedAt)
	}
	if m.operator != nil {
		fields = append(fields, chat.FieldFrom)
	}
	if m.message != nil {
		fields = append(fields, chat.FieldMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chat.FieldCreatedAt:
		return m.CreatedAt()
	case chat.FieldFrom:
		return m.From()
	case chat.FieldMessage:
		return m.Message()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chat.FieldFrom:
		return m.OldFrom(ctx)
	case chat.FieldMessage:
		return m.OldMessage(ctx)
	}
	return nil, fmt.Errorf("unknown Chat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chat.FieldFrom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case chat.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChatMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Chat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chat.FieldFrom) {
		fields = append(fields, chat.FieldFrom)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChatMutation) ClearField(name string) error {
	switch name {
	case chat.FieldFrom:
		m.ClearFrom()
		return nil
	}
	return fmt.Errorf("unknown Chat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChatMutation) ResetField(name string) error {
	switch name {
	case chat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chat.FieldFrom:
		m.ResetFrom()
		return nil
	case chat.FieldMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChatMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.operator != nil {
		edges = append(edges, chat.EdgeOperator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chat.EdgeOperator:
		if id := m.operator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedoperator {
		edges = append(edges, chat.EdgeOperator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChatMutation) EdgeCleared(name string) bool {
	switch name {
	case chat.EdgeOperator:
		return m.clearedoperator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChatMutation) ClearEdge(name string) error {
	switch name {
	case chat.EdgeOperator:
		m.ClearOperator()
		return nil
	}
	return fmt.Errorf("unknown Chat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChatMutation) ResetEdge(name string) error {
	switch name {
	case chat.EdgeOperator:
		m.ResetOperator()
		return nil
	}
	return fmt.Errorf("unknown Chat edge %s", name)
}

// CredentialMutation represents an operation that mutates the Credential nodes in the graph.
type CredentialMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	username      *string
	secret        *string
	realm         *string
	host          *string
	note          *string
	color         *uint32
	addcolor      *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Credential, error)
	predicates    []predicate.Credential
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// credentialOption allows management of the mutation configuration using functional options.
type credentialOption func(*CredentialMutation)

// newCredentialMutation creates new mutation for the Credential entity.
func newCredentialMutation(c config, op Op, opts ...credentialOption) *CredentialMutation {
	m := &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialID sets the ID field of the mutation.
func withCredentialID(id int) credentialOption {
	return func(m *CredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *Credential
		)
		m.oldValue = func(ctx context.Context) (*Credential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredential sets the old Credential of the mutation.
func withCredential(node *Credential) credentialOption {
	return func(m *CredentialMutation) {
		m.oldValue = func(context.Context) (*Credential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CredentialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CredentialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CredentialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CredentialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CredentialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CredentialMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CredentialMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CredentialMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[credential.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CredentialMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[credential.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CredentialMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, credential.FieldDeletedAt)
}

// SetUsername sets the "username" field.
func (m *CredentialMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *CredentialMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *CredentialMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[credential.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *CredentialMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[credential.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *CredentialMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, credential.FieldUsername)
}

// SetSecret sets the "secret" field.
func (m *CredentialMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *CredentialMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ClearSecret clears the value of the "secret" field.
func (m *CredentialMutation) ClearSecret() {
	m.secret = nil
	m.clearedFields[credential.FieldSecret] = struct{}{}
}

// SecretCleared returns if the "secret" field was cleared in this mutation.
func (m *CredentialMutation) SecretCleared() bool {
	_, ok := m.clearedFields[credential.FieldSecret]
	return ok
}

// ResetSecret resets all changes to the "secret" field.
func (m *CredentialMutation) ResetSecret() {
	m.secret = nil
	delete(m.clearedFields, credential.FieldSecret)
}

// SetRealm sets the "realm" field.
func (m *CredentialMutation) SetRealm(s string) {
	m.realm = &s
}

// Realm returns the value of the "realm" field in the mutation.
func (m *CredentialMutation) Realm() (r string, exists bool) {
	v := m.realm
	if v == nil {
		return
	}
	return *v, true
}

// OldRealm returns the old "realm" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldRealm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealm: %w", err)
	}
	return oldValue.Realm, nil
}

// ClearRealm clears the value of the "realm" field.
func (m *CredentialMutation) ClearRealm() {
	m.realm = nil
	m.clearedFields[credential.FieldRealm] = struct{}{}
}

// RealmCleared returns if the "realm" field was cleared in this mutation.
func (m *CredentialMutation) RealmCleared() bool {
	_, ok := m.clearedFields[credential.FieldRealm]
	return ok
}

// ResetRealm resets all changes to the "realm" field.
func (m *CredentialMutation) ResetRealm() {
	m.realm = nil
	delete(m.clearedFields, credential.FieldRealm)
}

// SetHost sets the "host" field.
func (m *CredentialMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *CredentialMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ClearHost clears the value of the "host" field.
func (m *CredentialMutation) ClearHost() {
	m.host = nil
	m.clearedFields[credential.FieldHost] = struct{}{}
}

// HostCleared returns if the "host" field was cleared in this mutation.
func (m *CredentialMutation) HostCleared() bool {
	_, ok := m.clearedFields[credential.FieldHost]
	return ok
}

// ResetHost resets all changes to the "host" field.
func (m *CredentialMutation) ResetHost() {
	m.host = nil
	delete(m.clearedFields, credential.FieldHost)
}

// SetNote sets the "note" field.
func (m *CredentialMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *CredentialMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *CredentialMutation) ClearNote() {
	m.note = nil
	m.clearedFields[credential.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *CredentialMutation) NoteCleared() bool {
	_, ok := m.clearedFields[credential.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *CredentialMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, credential.FieldNote)
}

// SetColor sets the "color" field.
func (m *CredentialMutation) SetColor(u uint32) {
	m.color = &u
	m.addcolor = nil
}

// Color returns the value of the "color" field in the mutation.
func (m *CredentialMutation) Color() (r uint32, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldColor(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// AddColor adds u to the "color" field.
func (m *CredentialMutation) AddColor(u int32) {
	if m.addcolor != nil {
		*m.addcolor += u
	} else {
		m.addcolor = &u
	}
}

// AddedColor returns the value that was added to the "color" field in this mutation.
func (m *CredentialMutation) AddedColor() (r int32, exists bool) {
	v := m.addcolor
	if v == nil {
		return
	}
	return *v, true
}

// ResetColor resets all changes to the "color" field.
func (m *CredentialMutation) ResetColor() {
	m.color = nil
	m.addcolor = nil
}

// Where appends a list predicates to the CredentialMutation builder.
func (m *CredentialMutation) Where(ps ...predicate.Credential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, credential.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, credential.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, credential.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, credential.FieldUsername)
	}
	if m.secret != nil {
		fields = append(fields, credential.FieldSecret)
	}
	if m.realm != nil {
		fields = append(fields, credential.FieldRealm)
	}
	if m.host != nil {
		fields = append(fields, credential.FieldHost)
	}
	if m.note != nil {
		fields = append(fields, credential.FieldNote)
	}
	if m.color != nil {
		fields = append(fields, credential.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldCreatedAt:
		return m.CreatedAt()
	case credential.FieldUpdatedAt:
		return m.UpdatedAt()
	case credential.FieldDeletedAt:
		return m.DeletedAt()
	case credential.FieldUsername:
		return m.Username()
	case credential.FieldSecret:
		return m.Secret()
	case credential.FieldRealm:
		return m.Realm()
	case credential.FieldHost:
		return m.Host()
	case credential.FieldNote:
		return m.Note()
	case credential.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case credential.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case credential.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case credential.FieldUsername:
		return m.OldUsername(ctx)
	case credential.FieldSecret:
		return m.OldSecret(ctx)
	case credential.FieldRealm:
		return m.OldRealm(ctx)
	case credential.FieldHost:
		return m.OldHost(ctx)
	case credential.FieldNote:
		return m.OldNote(ctx)
	case credential.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Credential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case credential.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case credential.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case credential.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case credential.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case credential.FieldRealm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealm(v)
		return nil
	case credential.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case credential.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case credential.FieldColor:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialMutation) AddedFields() []string {
	var fields []string
	if m.addcolor != nil {
		fields = append(fields, credential.FieldColor)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldColor:
		return m.AddedColor()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case credential.FieldColor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColor(v)
		return nil
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credential.FieldDeletedAt) {
		fields = append(fields, credential.FieldDeletedAt)
	}
	if m.FieldCleared(credential.FieldUsername) {
		fields = append(fields, credential.FieldUsername)
	}
	if m.FieldCleared(credential.FieldSecret) {
		fields = append(fields, credential.FieldSecret)
	}
	if m.FieldCleared(credential.FieldRealm) {
		fields = append(fields, credential.FieldRealm)
	}
	if m.FieldCleared(credential.FieldHost) {
		fields = append(fields, credential.FieldHost)
	}
	if m.FieldCleared(credential.FieldNote) {
		fields = append(fields, credential.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	switch name {
	case credential.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case credential.FieldUsername:
		m.ClearUsername()
		return nil
	case credential.FieldSecret:
		m.ClearSecret()
		return nil
	case credential.FieldRealm:
		m.ClearRealm()
		return nil
	case credential.FieldHost:
		m.ClearHost()
		return nil
	case credential.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case credential.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case credential.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case credential.FieldUsername:
		m.ResetUsername()
		return nil
	case credential.FieldSecret:
		m.ResetSecret()
		return nil
	case credential.FieldRealm:
		m.ResetRealm()
		return nil
	case credential.FieldHost:
		m.ResetHost()
		return nil
	case credential.FieldNote:
		m.ResetNote()
		return nil
	case credential.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Credential edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op              Op
	typ             string
	id              *int
	cmd             *string
	visible         *bool
	created_at      *time.Time
	closed_at       *time.Time
	clearedFields   map[string]struct{}
	beacon          *int
	clearedbeacon   bool
	operator        *int
	clearedoperator bool
	message         map[int]struct{}
	removedmessage  map[int]struct{}
	clearedmessage  bool
	task            map[int]struct{}
	removedtask     map[int]struct{}
	clearedtask     bool
	done            bool
	oldValue        func(context.Context) (*Group, error)
	predicates      []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id int) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBid sets the "bid" field.
func (m *GroupMutation) SetBid(i int) {
	m.beacon = &i
}

// Bid returns the value of the "bid" field in the mutation.
func (m *GroupMutation) Bid() (r int, exists bool) {
	v := m.beacon
	if v == nil {
		return
	}
	return *v, true
}

// OldBid returns the old "bid" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldBid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBid: %w", err)
	}
	return oldValue.Bid, nil
}

// ResetBid resets all changes to the "bid" field.
func (m *GroupMutation) ResetBid() {
	m.beacon = nil
}

// SetCmd sets the "cmd" field.
func (m *GroupMutation) SetCmd(s string) {
	m.cmd = &s
}

// Cmd returns the value of the "cmd" field in the mutation.
func (m *GroupMutation) Cmd() (r string, exists bool) {
	v := m.cmd
	if v == nil {
		return
	}
	return *v, true
}

// OldCmd returns the old "cmd" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCmd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCmd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCmd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCmd: %w", err)
	}
	return oldValue.Cmd, nil
}

// ResetCmd resets all changes to the "cmd" field.
func (m *GroupMutation) ResetCmd() {
	m.cmd = nil
}

// SetVisible sets the "visible" field.
func (m *GroupMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *GroupMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ResetVisible resets all changes to the "visible" field.
func (m *GroupMutation) ResetVisible() {
	m.visible = nil
}

// SetAuthor sets the "author" field.
func (m *GroupMutation) SetAuthor(i int) {
	m.operator = &i
}

// Author returns the value of the "author" field in the mutation.
func (m *GroupMutation) Author() (r int, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldAuthor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *GroupMutation) ResetAuthor() {
	m.operator = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetClosedAt sets the "closed_at" field.
func (m *GroupMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *GroupMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldClosedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ClearClosedAt clears the value of the "closed_at" field.
func (m *GroupMutation) ClearClosedAt() {
	m.closed_at = nil
	m.clearedFields[group.FieldClosedAt] = struct{}{}
}

// ClosedAtCleared returns if the "closed_at" field was cleared in this mutation.
func (m *GroupMutation) ClosedAtCleared() bool {
	_, ok := m.clearedFields[group.FieldClosedAt]
	return ok
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *GroupMutation) ResetClosedAt() {
	m.closed_at = nil
	delete(m.clearedFields, group.FieldClosedAt)
}

// SetBeaconID sets the "beacon" edge to the Beacon entity by id.
func (m *GroupMutation) SetBeaconID(id int) {
	m.beacon = &id
}

// ClearBeacon clears the "beacon" edge to the Beacon entity.
func (m *GroupMutation) ClearBeacon() {
	m.clearedbeacon = true
	m.clearedFields[group.FieldBid] = struct{}{}
}

// BeaconCleared reports if the "beacon" edge to the Beacon entity was cleared.
func (m *GroupMutation) BeaconCleared() bool {
	return m.clearedbeacon
}

// BeaconID returns the "beacon" edge ID in the mutation.
func (m *GroupMutation) BeaconID() (id int, exists bool) {
	if m.beacon != nil {
		return *m.beacon, true
	}
	return
}

// BeaconIDs returns the "beacon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BeaconID instead. It exists only for internal usage by the builders.
func (m *GroupMutation) BeaconIDs() (ids []int) {
	if id := m.beacon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBeacon resets all changes to the "beacon" edge.
func (m *GroupMutation) ResetBeacon() {
	m.beacon = nil
	m.clearedbeacon = false
}

// SetOperatorID sets the "operator" edge to the Operator entity by id.
func (m *GroupMutation) SetOperatorID(id int) {
	m.operator = &id
}

// ClearOperator clears the "operator" edge to the Operator entity.
func (m *GroupMutation) ClearOperator() {
	m.clearedoperator = true
	m.clearedFields[group.FieldAuthor] = struct{}{}
}

// OperatorCleared reports if the "operator" edge to the Operator entity was cleared.
func (m *GroupMutation) OperatorCleared() bool {
	return m.clearedoperator
}

// OperatorID returns the "operator" edge ID in the mutation.
func (m *GroupMutation) OperatorID() (id int, exists bool) {
	if m.operator != nil {
		return *m.operator, true
	}
	return
}

// OperatorIDs returns the "operator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OperatorID instead. It exists only for internal usage by the builders.
func (m *GroupMutation) OperatorIDs() (ids []int) {
	if id := m.operator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperator resets all changes to the "operator" edge.
func (m *GroupMutation) ResetOperator() {
	m.operator = nil
	m.clearedoperator = false
}

// AddMessageIDs adds the "message" edge to the Message entity by ids.
func (m *GroupMutation) AddMessageIDs(ids ...int) {
	if m.message == nil {
		m.message = make(map[int]struct{})
	}
	for i := range ids {
		m.message[ids[i]] = struct{}{}
	}
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *GroupMutation) ClearMessage() {
	m.clearedmessage = true
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *GroupMutation) MessageCleared() bool {
	return m.clearedmessage
}

// RemoveMessageIDs removes the "message" edge to the Message entity by IDs.
func (m *GroupMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessage == nil {
		m.removedmessage = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.message, ids[i])
		m.removedmessage[ids[i]] = struct{}{}
	}
}

// RemovedMessage returns the removed IDs of the "message" edge to the Message entity.
func (m *GroupMutation) RemovedMessageIDs() (ids []int) {
	for id := range m.removedmessage {
		ids = append(ids, id)
	}
	return
}

// MessageIDs returns the "message" edge IDs in the mutation.
func (m *GroupMutation) MessageIDs() (ids []int) {
	for id := range m.message {
		ids = append(ids, id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *GroupMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
	m.removedmessage = nil
}

// AddTaskIDs adds the "task" edge to the Task entity by ids.
func (m *GroupMutation) AddTaskIDs(ids ...int) {
	if m.task == nil {
		m.task = make(map[int]struct{})
	}
	for i := range ids {
		m.task[ids[i]] = struct{}{}
	}
}

// ClearTask clears the "task" edge to the Task entity.
func (m *GroupMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *GroupMutation) TaskCleared() bool {
	return m.clearedtask
}

// RemoveTaskIDs removes the "task" edge to the Task entity by IDs.
func (m *GroupMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtask == nil {
		m.removedtask = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.task, ids[i])
		m.removedtask[ids[i]] = struct{}{}
	}
}

// RemovedTask returns the removed IDs of the "task" edge to the Task entity.
func (m *GroupMutation) RemovedTaskIDs() (ids []int) {
	for id := range m.removedtask {
		ids = append(ids, id)
	}
	return
}

// TaskIDs returns the "task" edge IDs in the mutation.
func (m *GroupMutation) TaskIDs() (ids []int) {
	for id := range m.task {
		ids = append(ids, id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *GroupMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
	m.removedtask = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.beacon != nil {
		fields = append(fields, group.FieldBid)
	}
	if m.cmd != nil {
		fields = append(fields, group.FieldCmd)
	}
	if m.visible != nil {
		fields = append(fields, group.FieldVisible)
	}
	if m.operator != nil {
		fields = append(fields, group.FieldAuthor)
	}
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, group.FieldClosedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldBid:
		return m.Bid()
	case group.FieldCmd:
		return m.Cmd()
	case group.FieldVisible:
		return m.Visible()
	case group.FieldAuthor:
		return m.Author()
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldClosedAt:
		return m.ClosedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldBid:
		return m.OldBid(ctx)
	case group.FieldCmd:
		return m.OldCmd(ctx)
	case group.FieldVisible:
		return m.OldVisible(ctx)
	case group.FieldAuthor:
		return m.OldAuthor(ctx)
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldClosedAt:
		return m.OldClosedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldBid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBid(v)
		return nil
	case group.FieldCmd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCmd(v)
		return nil
	case group.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	case group.FieldAuthor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(group.FieldClosedAt) {
		fields = append(fields, group.FieldClosedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	switch name {
	case group.FieldClosedAt:
		m.ClearClosedAt()
		return nil
	}
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldBid:
		m.ResetBid()
		return nil
	case group.FieldCmd:
		m.ResetCmd()
		return nil
	case group.FieldVisible:
		m.ResetVisible()
		return nil
	case group.FieldAuthor:
		m.ResetAuthor()
		return nil
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.beacon != nil {
		edges = append(edges, group.EdgeBeacon)
	}
	if m.operator != nil {
		edges = append(edges, group.EdgeOperator)
	}
	if m.message != nil {
		edges = append(edges, group.EdgeMessage)
	}
	if m.task != nil {
		edges = append(edges, group.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeBeacon:
		if id := m.beacon; id != nil {
			return []ent.Value{*id}
		}
	case group.EdgeOperator:
		if id := m.operator; id != nil {
			return []ent.Value{*id}
		}
	case group.EdgeMessage:
		ids := make([]ent.Value, 0, len(m.message))
		for id := range m.message {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeTask:
		ids := make([]ent.Value, 0, len(m.task))
		for id := range m.task {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmessage != nil {
		edges = append(edges, group.EdgeMessage)
	}
	if m.removedtask != nil {
		edges = append(edges, group.EdgeTask)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeMessage:
		ids := make([]ent.Value, 0, len(m.removedmessage))
		for id := range m.removedmessage {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeTask:
		ids := make([]ent.Value, 0, len(m.removedtask))
		for id := range m.removedtask {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbeacon {
		edges = append(edges, group.EdgeBeacon)
	}
	if m.clearedoperator {
		edges = append(edges, group.EdgeOperator)
	}
	if m.clearedmessage {
		edges = append(edges, group.EdgeMessage)
	}
	if m.clearedtask {
		edges = append(edges, group.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeBeacon:
		return m.clearedbeacon
	case group.EdgeOperator:
		return m.clearedoperator
	case group.EdgeMessage:
		return m.clearedmessage
	case group.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	case group.EdgeBeacon:
		m.ClearBeacon()
		return nil
	case group.EdgeOperator:
		m.ClearOperator()
		return nil
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeBeacon:
		m.ResetBeacon()
		return nil
	case group.EdgeOperator:
		m.ResetOperator()
		return nil
	case group.EdgeMessage:
		m.ResetMessage()
		return nil
	case group.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// ListenerMutation represents an operation that mutates the Listener nodes in the graph.
type ListenerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token         *string
	name          *string
	ip            *types.Inet
	port          *uint16
	addport       *int16
	color         *uint32
	addcolor      *int32
	note          *string
	last          *time.Time
	clearedFields map[string]struct{}
	beacon        map[int]struct{}
	removedbeacon map[int]struct{}
	clearedbeacon bool
	done          bool
	oldValue      func(context.Context) (*Listener, error)
	predicates    []predicate.Listener
}

var _ ent.Mutation = (*ListenerMutation)(nil)

// listenerOption allows management of the mutation configuration using functional options.
type listenerOption func(*ListenerMutation)

// newListenerMutation creates new mutation for the Listener entity.
func newListenerMutation(c config, op Op, opts ...listenerOption) *ListenerMutation {
	m := &ListenerMutation{
		config:        c,
		op:            op,
		typ:           TypeListener,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withListenerID sets the ID field of the mutation.
func withListenerID(id int) listenerOption {
	return func(m *ListenerMutation) {
		var (
			err   error
			once  sync.Once
			value *Listener
		)
		m.oldValue = func(ctx context.Context) (*Listener, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Listener.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withListener sets the old Listener of the mutation.
func withListener(node *Listener) listenerOption {
	return func(m *ListenerMutation) {
		m.oldValue = func(context.Context) (*Listener, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ListenerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ListenerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ListenerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ListenerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Listener.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ListenerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ListenerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ListenerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ListenerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ListenerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ListenerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ListenerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ListenerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ListenerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[listener.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ListenerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[listener.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ListenerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, listener.FieldDeletedAt)
}

// SetToken sets the "token" field.
func (m *ListenerMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *ListenerMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *ListenerMutation) ClearToken() {
	m.token = nil
	m.clearedFields[listener.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *ListenerMutation) TokenCleared() bool {
	_, ok := m.clearedFields[listener.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *ListenerMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, listener.FieldToken)
}

// SetName sets the "name" field.
func (m *ListenerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ListenerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ListenerMutation) ClearName() {
	m.name = nil
	m.clearedFields[listener.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ListenerMutation) NameCleared() bool {
	_, ok := m.clearedFields[listener.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ListenerMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, listener.FieldName)
}

// SetIP sets the "ip" field.
func (m *ListenerMutation) SetIP(t types.Inet) {
	m.ip = &t
}

// IP returns the value of the "ip" field in the mutation.
func (m *ListenerMutation) IP() (r types.Inet, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldIP(ctx context.Context) (v types.Inet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *ListenerMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[listener.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *ListenerMutation) IPCleared() bool {
	_, ok := m.clearedFields[listener.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *ListenerMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, listener.FieldIP)
}

// SetPort sets the "port" field.
func (m *ListenerMutation) SetPort(u uint16) {
	m.port = &u
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *ListenerMutation) Port() (r uint16, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldPort(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds u to the "port" field.
func (m *ListenerMutation) AddPort(u int16) {
	if m.addport != nil {
		*m.addport += u
	} else {
		m.addport = &u
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *ListenerMutation) AddedPort() (r int16, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ClearPort clears the value of the "port" field.
func (m *ListenerMutation) ClearPort() {
	m.port = nil
	m.addport = nil
	m.clearedFields[listener.FieldPort] = struct{}{}
}

// PortCleared returns if the "port" field was cleared in this mutation.
func (m *ListenerMutation) PortCleared() bool {
	_, ok := m.clearedFields[listener.FieldPort]
	return ok
}

// ResetPort resets all changes to the "port" field.
func (m *ListenerMutation) ResetPort() {
	m.port = nil
	m.addport = nil
	delete(m.clearedFields, listener.FieldPort)
}

// SetColor sets the "color" field.
func (m *ListenerMutation) SetColor(u uint32) {
	m.color = &u
	m.addcolor = nil
}

// Color returns the value of the "color" field in the mutation.
func (m *ListenerMutation) Color() (r uint32, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldColor(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// AddColor adds u to the "color" field.
func (m *ListenerMutation) AddColor(u int32) {
	if m.addcolor != nil {
		*m.addcolor += u
	} else {
		m.addcolor = &u
	}
}

// AddedColor returns the value that was added to the "color" field in this mutation.
func (m *ListenerMutation) AddedColor() (r int32, exists bool) {
	v := m.addcolor
	if v == nil {
		return
	}
	return *v, true
}

// ResetColor resets all changes to the "color" field.
func (m *ListenerMutation) ResetColor() {
	m.color = nil
	m.addcolor = nil
}

// SetNote sets the "note" field.
func (m *ListenerMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *ListenerMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *ListenerMutation) ClearNote() {
	m.note = nil
	m.clearedFields[listener.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *ListenerMutation) NoteCleared() bool {
	_, ok := m.clearedFields[listener.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *ListenerMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, listener.FieldNote)
}

// SetLast sets the "last" field.
func (m *ListenerMutation) SetLast(t time.Time) {
	m.last = &t
}

// Last returns the value of the "last" field in the mutation.
func (m *ListenerMutation) Last() (r time.Time, exists bool) {
	v := m.last
	if v == nil {
		return
	}
	return *v, true
}

// OldLast returns the old "last" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast: %w", err)
	}
	return oldValue.Last, nil
}

// ResetLast resets all changes to the "last" field.
func (m *ListenerMutation) ResetLast() {
	m.last = nil
}

// AddBeaconIDs adds the "beacon" edge to the Beacon entity by ids.
func (m *ListenerMutation) AddBeaconIDs(ids ...int) {
	if m.beacon == nil {
		m.beacon = make(map[int]struct{})
	}
	for i := range ids {
		m.beacon[ids[i]] = struct{}{}
	}
}

// ClearBeacon clears the "beacon" edge to the Beacon entity.
func (m *ListenerMutation) ClearBeacon() {
	m.clearedbeacon = true
}

// BeaconCleared reports if the "beacon" edge to the Beacon entity was cleared.
func (m *ListenerMutation) BeaconCleared() bool {
	return m.clearedbeacon
}

// RemoveBeaconIDs removes the "beacon" edge to the Beacon entity by IDs.
func (m *ListenerMutation) RemoveBeaconIDs(ids ...int) {
	if m.removedbeacon == nil {
		m.removedbeacon = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.beacon, ids[i])
		m.removedbeacon[ids[i]] = struct{}{}
	}
}

// RemovedBeacon returns the removed IDs of the "beacon" edge to the Beacon entity.
func (m *ListenerMutation) RemovedBeaconIDs() (ids []int) {
	for id := range m.removedbeacon {
		ids = append(ids, id)
	}
	return
}

// BeaconIDs returns the "beacon" edge IDs in the mutation.
func (m *ListenerMutation) BeaconIDs() (ids []int) {
	for id := range m.beacon {
		ids = append(ids, id)
	}
	return
}

// ResetBeacon resets all changes to the "beacon" edge.
func (m *ListenerMutation) ResetBeacon() {
	m.beacon = nil
	m.clearedbeacon = false
	m.removedbeacon = nil
}

// Where appends a list predicates to the ListenerMutation builder.
func (m *ListenerMutation) Where(ps ...predicate.Listener) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ListenerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ListenerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Listener, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ListenerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ListenerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Listener).
func (m *ListenerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ListenerMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, listener.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, listener.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, listener.FieldDeletedAt)
	}
	if m.token != nil {
		fields = append(fields, listener.FieldToken)
	}
	if m.name != nil {
		fields = append(fields, listener.FieldName)
	}
	if m.ip != nil {
		fields = append(fields, listener.FieldIP)
	}
	if m.port != nil {
		fields = append(fields, listener.FieldPort)
	}
	if m.color != nil {
		fields = append(fields, listener.FieldColor)
	}
	if m.note != nil {
		fields = append(fields, listener.FieldNote)
	}
	if m.last != nil {
		fields = append(fields, listener.FieldLast)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ListenerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case listener.FieldCreatedAt:
		return m.CreatedAt()
	case listener.FieldUpdatedAt:
		return m.UpdatedAt()
	case listener.FieldDeletedAt:
		return m.DeletedAt()
	case listener.FieldToken:
		return m.Token()
	case listener.FieldName:
		return m.Name()
	case listener.FieldIP:
		return m.IP()
	case listener.FieldPort:
		return m.Port()
	case listener.FieldColor:
		return m.Color()
	case listener.FieldNote:
		return m.Note()
	case listener.FieldLast:
		return m.Last()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ListenerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case listener.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case listener.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case listener.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case listener.FieldToken:
		return m.OldToken(ctx)
	case listener.FieldName:
		return m.OldName(ctx)
	case listener.FieldIP:
		return m.OldIP(ctx)
	case listener.FieldPort:
		return m.OldPort(ctx)
	case listener.FieldColor:
		return m.OldColor(ctx)
	case listener.FieldNote:
		return m.OldNote(ctx)
	case listener.FieldLast:
		return m.OldLast(ctx)
	}
	return nil, fmt.Errorf("unknown Listener field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ListenerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case listener.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case listener.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case listener.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case listener.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case listener.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case listener.FieldIP:
		v, ok := value.(types.Inet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case listener.FieldPort:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case listener.FieldColor:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case listener.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case listener.FieldLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast(v)
		return nil
	}
	return fmt.Errorf("unknown Listener field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ListenerMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, listener.FieldPort)
	}
	if m.addcolor != nil {
		fields = append(fields, listener.FieldColor)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ListenerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case listener.FieldPort:
		return m.AddedPort()
	case listener.FieldColor:
		return m.AddedColor()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ListenerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case listener.FieldPort:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	case listener.FieldColor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColor(v)
		return nil
	}
	return fmt.Errorf("unknown Listener numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ListenerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(listener.FieldDeletedAt) {
		fields = append(fields, listener.FieldDeletedAt)
	}
	if m.FieldCleared(listener.FieldToken) {
		fields = append(fields, listener.FieldToken)
	}
	if m.FieldCleared(listener.FieldName) {
		fields = append(fields, listener.FieldName)
	}
	if m.FieldCleared(listener.FieldIP) {
		fields = append(fields, listener.FieldIP)
	}
	if m.FieldCleared(listener.FieldPort) {
		fields = append(fields, listener.FieldPort)
	}
	if m.FieldCleared(listener.FieldNote) {
		fields = append(fields, listener.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ListenerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ListenerMutation) ClearField(name string) error {
	switch name {
	case listener.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case listener.FieldToken:
		m.ClearToken()
		return nil
	case listener.FieldName:
		m.ClearName()
		return nil
	case listener.FieldIP:
		m.ClearIP()
		return nil
	case listener.FieldPort:
		m.ClearPort()
		return nil
	case listener.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Listener nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ListenerMutation) ResetField(name string) error {
	switch name {
	case listener.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case listener.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case listener.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case listener.FieldToken:
		m.ResetToken()
		return nil
	case listener.FieldName:
		m.ResetName()
		return nil
	case listener.FieldIP:
		m.ResetIP()
		return nil
	case listener.FieldPort:
		m.ResetPort()
		return nil
	case listener.FieldColor:
		m.ResetColor()
		return nil
	case listener.FieldNote:
		m.ResetNote()
		return nil
	case listener.FieldLast:
		m.ResetLast()
		return nil
	}
	return fmt.Errorf("unknown Listener field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ListenerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.beacon != nil {
		edges = append(edges, listener.EdgeBeacon)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ListenerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case listener.EdgeBeacon:
		ids := make([]ent.Value, 0, len(m.beacon))
		for id := range m.beacon {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ListenerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbeacon != nil {
		edges = append(edges, listener.EdgeBeacon)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ListenerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case listener.EdgeBeacon:
		ids := make([]ent.Value, 0, len(m.removedbeacon))
		for id := range m.removedbeacon {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ListenerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbeacon {
		edges = append(edges, listener.EdgeBeacon)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ListenerMutation) EdgeCleared(name string) bool {
	switch name {
	case listener.EdgeBeacon:
		return m.clearedbeacon
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ListenerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Listener unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ListenerMutation) ResetEdge(name string) error {
	switch name {
	case listener.EdgeBeacon:
		m.ResetBeacon()
		return nil
	}
	return fmt.Errorf("unknown Listener edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_type         *defaults.TaskMessage
	message       *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	group         *int
	clearedgroup  bool
	done          bool
	oldValue      func(context.Context) (*Message, error)
	predicates    []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGid sets the "gid" field.
func (m *MessageMutation) SetGid(i int) {
	m.group = &i
}

// Gid returns the value of the "gid" field in the mutation.
func (m *MessageMutation) Gid() (r int, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGid returns the old "gid" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldGid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGid: %w", err)
	}
	return oldValue.Gid, nil
}

// ResetGid resets all changes to the "gid" field.
func (m *MessageMutation) ResetGid() {
	m.group = nil
}

// SetType sets the "type" field.
func (m *MessageMutation) SetType(dm defaults.TaskMessage) {
	m._type = &dm
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessageMutation) GetType() (r defaults.TaskMessage, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldType(ctx context.Context) (v defaults.TaskMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessageMutation) ResetType() {
	m._type = nil
}

// SetMessage sets the "message" field.
func (m *MessageMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *MessageMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *MessageMutation) ResetMessage() {
	m.message = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *MessageMutation) SetGroupID(id int) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *MessageMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[message.FieldGid] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *MessageMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *MessageMutation) GroupID() (id int, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) GroupIDs() (ids []int) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *MessageMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.group != nil {
		fields = append(fields, message.FieldGid)
	}
	if m._type != nil {
		fields = append(fields, message.FieldType)
	}
	if m.message != nil {
		fields = append(fields, message.FieldMessage)
	}
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldGid:
		return m.Gid()
	case message.FieldType:
		return m.GetType()
	case message.FieldMessage:
		return m.Message()
	case message.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldGid:
		return m.OldGid(ctx)
	case message.FieldType:
		return m.OldType(ctx)
	case message.FieldMessage:
		return m.OldMessage(ctx)
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldGid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGid(v)
		return nil
	case message.FieldType:
		v, ok := value.(defaults.TaskMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case message.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldGid:
		m.ResetGid()
		return nil
	case message.FieldType:
		m.ResetType()
		return nil
	case message.FieldMessage:
		m.ResetMessage()
		return nil
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.group != nil {
		edges = append(edges, message.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgroup {
		edges = append(edges, message.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// OperatorMutation represents an operation that mutates the Operator nodes in the graph.
type OperatorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	username      *string
	token         *string
	color         *uint32
	addcolor      *int32
	last          *time.Time
	clearedFields map[string]struct{}
	chat          map[int]struct{}
	removedchat   map[int]struct{}
	clearedchat   bool
	group         map[int]struct{}
	removedgroup  map[int]struct{}
	clearedgroup  bool
	done          bool
	oldValue      func(context.Context) (*Operator, error)
	predicates    []predicate.Operator
}

var _ ent.Mutation = (*OperatorMutation)(nil)

// operatorOption allows management of the mutation configuration using functional options.
type operatorOption func(*OperatorMutation)

// newOperatorMutation creates new mutation for the Operator entity.
func newOperatorMutation(c config, op Op, opts ...operatorOption) *OperatorMutation {
	m := &OperatorMutation{
		config:        c,
		op:            op,
		typ:           TypeOperator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperatorID sets the ID field of the mutation.
func withOperatorID(id int) operatorOption {
	return func(m *OperatorMutation) {
		var (
			err   error
			once  sync.Once
			value *Operator
		)
		m.oldValue = func(ctx context.Context) (*Operator, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Operator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperator sets the old Operator of the mutation.
func withOperator(node *Operator) operatorOption {
	return func(m *OperatorMutation) {
		m.oldValue = func(context.Context) (*Operator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperatorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperatorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OperatorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OperatorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Operator.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OperatorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OperatorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OperatorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OperatorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OperatorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OperatorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OperatorMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OperatorMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OperatorMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[operator.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OperatorMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[operator.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OperatorMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, operator.FieldDeletedAt)
}

// SetUsername sets the "username" field.
func (m *OperatorMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *OperatorMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *OperatorMutation) ResetUsername() {
	m.username = nil
}

// SetToken sets the "token" field.
func (m *OperatorMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *OperatorMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *OperatorMutation) ClearToken() {
	m.token = nil
	m.clearedFields[operator.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *OperatorMutation) TokenCleared() bool {
	_, ok := m.clearedFields[operator.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *OperatorMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, operator.FieldToken)
}

// SetColor sets the "color" field.
func (m *OperatorMutation) SetColor(u uint32) {
	m.color = &u
	m.addcolor = nil
}

// Color returns the value of the "color" field in the mutation.
func (m *OperatorMutation) Color() (r uint32, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldColor(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// AddColor adds u to the "color" field.
func (m *OperatorMutation) AddColor(u int32) {
	if m.addcolor != nil {
		*m.addcolor += u
	} else {
		m.addcolor = &u
	}
}

// AddedColor returns the value that was added to the "color" field in this mutation.
func (m *OperatorMutation) AddedColor() (r int32, exists bool) {
	v := m.addcolor
	if v == nil {
		return
	}
	return *v, true
}

// ResetColor resets all changes to the "color" field.
func (m *OperatorMutation) ResetColor() {
	m.color = nil
	m.addcolor = nil
}

// SetLast sets the "last" field.
func (m *OperatorMutation) SetLast(t time.Time) {
	m.last = &t
}

// Last returns the value of the "last" field in the mutation.
func (m *OperatorMutation) Last() (r time.Time, exists bool) {
	v := m.last
	if v == nil {
		return
	}
	return *v, true
}

// OldLast returns the old "last" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast: %w", err)
	}
	return oldValue.Last, nil
}

// ResetLast resets all changes to the "last" field.
func (m *OperatorMutation) ResetLast() {
	m.last = nil
}

// AddChatIDs adds the "chat" edge to the Chat entity by ids.
func (m *OperatorMutation) AddChatIDs(ids ...int) {
	if m.chat == nil {
		m.chat = make(map[int]struct{})
	}
	for i := range ids {
		m.chat[ids[i]] = struct{}{}
	}
}

// ClearChat clears the "chat" edge to the Chat entity.
func (m *OperatorMutation) ClearChat() {
	m.clearedchat = true
}

// ChatCleared reports if the "chat" edge to the Chat entity was cleared.
func (m *OperatorMutation) ChatCleared() bool {
	return m.clearedchat
}

// RemoveChatIDs removes the "chat" edge to the Chat entity by IDs.
func (m *OperatorMutation) RemoveChatIDs(ids ...int) {
	if m.removedchat == nil {
		m.removedchat = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.chat, ids[i])
		m.removedchat[ids[i]] = struct{}{}
	}
}

// RemovedChat returns the removed IDs of the "chat" edge to the Chat entity.
func (m *OperatorMutation) RemovedChatIDs() (ids []int) {
	for id := range m.removedchat {
		ids = append(ids, id)
	}
	return
}

// ChatIDs returns the "chat" edge IDs in the mutation.
func (m *OperatorMutation) ChatIDs() (ids []int) {
	for id := range m.chat {
		ids = append(ids, id)
	}
	return
}

// ResetChat resets all changes to the "chat" edge.
func (m *OperatorMutation) ResetChat() {
	m.chat = nil
	m.clearedchat = false
	m.removedchat = nil
}

// AddGroupIDs adds the "group" edge to the Group entity by ids.
func (m *OperatorMutation) AddGroupIDs(ids ...int) {
	if m.group == nil {
		m.group = make(map[int]struct{})
	}
	for i := range ids {
		m.group[ids[i]] = struct{}{}
	}
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *OperatorMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *OperatorMutation) GroupCleared() bool {
	return m.clearedgroup
}

// RemoveGroupIDs removes the "group" edge to the Group entity by IDs.
func (m *OperatorMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroup == nil {
		m.removedgroup = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.group, ids[i])
		m.removedgroup[ids[i]] = struct{}{}
	}
}

// RemovedGroup returns the removed IDs of the "group" edge to the Group entity.
func (m *OperatorMutation) RemovedGroupIDs() (ids []int) {
	for id := range m.removedgroup {
		ids = append(ids, id)
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
func (m *OperatorMutation) GroupIDs() (ids []int) {
	for id := range m.group {
		ids = append(ids, id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *OperatorMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
	m.removedgroup = nil
}

// Where appends a list predicates to the OperatorMutation builder.
func (m *OperatorMutation) Where(ps ...predicate.Operator) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OperatorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OperatorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Operator, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OperatorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OperatorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Operator).
func (m *OperatorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OperatorMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, operator.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, operator.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, operator.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, operator.FieldUsername)
	}
	if m.token != nil {
		fields = append(fields, operator.FieldToken)
	}
	if m.color != nil {
		fields = append(fields, operator.FieldColor)
	}
	if m.last != nil {
		fields = append(fields, operator.FieldLast)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OperatorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operator.FieldCreatedAt:
		return m.CreatedAt()
	case operator.FieldUpdatedAt:
		return m.UpdatedAt()
	case operator.FieldDeletedAt:
		return m.DeletedAt()
	case operator.FieldUsername:
		return m.Username()
	case operator.FieldToken:
		return m.Token()
	case operator.FieldColor:
		return m.Color()
	case operator.FieldLast:
		return m.Last()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OperatorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operator.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case operator.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case operator.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case operator.FieldUsername:
		return m.OldUsername(ctx)
	case operator.FieldToken:
		return m.OldToken(ctx)
	case operator.FieldColor:
		return m.OldColor(ctx)
	case operator.FieldLast:
		return m.OldLast(ctx)
	}
	return nil, fmt.Errorf("unknown Operator field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operator.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case operator.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case operator.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case operator.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case operator.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case operator.FieldColor:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case operator.FieldLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast(v)
		return nil
	}
	return fmt.Errorf("unknown Operator field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OperatorMutation) AddedFields() []string {
	var fields []string
	if m.addcolor != nil {
		fields = append(fields, operator.FieldColor)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OperatorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case operator.FieldColor:
		return m.AddedColor()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case operator.FieldColor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColor(v)
		return nil
	}
	return fmt.Errorf("unknown Operator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OperatorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(operator.FieldDeletedAt) {
		fields = append(fields, operator.FieldDeletedAt)
	}
	if m.FieldCleared(operator.FieldToken) {
		fields = append(fields, operator.FieldToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OperatorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperatorMutation) ClearField(name string) error {
	switch name {
	case operator.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case operator.FieldToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown Operator nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OperatorMutation) ResetField(name string) error {
	switch name {
	case operator.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case operator.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case operator.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case operator.FieldUsername:
		m.ResetUsername()
		return nil
	case operator.FieldToken:
		m.ResetToken()
		return nil
	case operator.FieldColor:
		m.ResetColor()
		return nil
	case operator.FieldLast:
		m.ResetLast()
		return nil
	}
	return fmt.Errorf("unknown Operator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OperatorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.chat != nil {
		edges = append(edges, operator.EdgeChat)
	}
	if m.group != nil {
		edges = append(edges, operator.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OperatorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operator.EdgeChat:
		ids := make([]ent.Value, 0, len(m.chat))
		for id := range m.chat {
			ids = append(ids, id)
		}
		return ids
	case operator.EdgeGroup:
		ids := make([]ent.Value, 0, len(m.group))
		for id := range m.group {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OperatorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchat != nil {
		edges = append(edges, operator.EdgeChat)
	}
	if m.removedgroup != nil {
		edges = append(edges, operator.EdgeGroup)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OperatorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case operator.EdgeChat:
		ids := make([]ent.Value, 0, len(m.removedchat))
		for id := range m.removedchat {
			ids = append(ids, id)
		}
		return ids
	case operator.EdgeGroup:
		ids := make([]ent.Value, 0, len(m.removedgroup))
		for id := range m.removedgroup {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OperatorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchat {
		edges = append(edges, operator.EdgeChat)
	}
	if m.clearedgroup {
		edges = append(edges, operator.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OperatorMutation) EdgeCleared(name string) bool {
	switch name {
	case operator.EdgeChat:
		return m.clearedchat
	case operator.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OperatorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Operator unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OperatorMutation) ResetEdge(name string) error {
	switch name {
	case operator.EdgeChat:
		m.ResetChat()
		return nil
	case operator.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown Operator edge %s", name)
}

// PkiMutation represents an operation that mutates the Pki nodes in the graph.
type PkiMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	_type         *pki.Type
	key           *[]byte
	cert          *[]byte
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Pki, error)
	predicates    []predicate.Pki
}

var _ ent.Mutation = (*PkiMutation)(nil)

// pkiOption allows management of the mutation configuration using functional options.
type pkiOption func(*PkiMutation)

// newPkiMutation creates new mutation for the Pki entity.
func newPkiMutation(c config, op Op, opts ...pkiOption) *PkiMutation {
	m := &PkiMutation{
		config:        c,
		op:            op,
		typ:           TypePki,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPkiID sets the ID field of the mutation.
func withPkiID(id int) pkiOption {
	return func(m *PkiMutation) {
		var (
			err   error
			once  sync.Once
			value *Pki
		)
		m.oldValue = func(ctx context.Context) (*Pki, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pki.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPki sets the old Pki of the mutation.
func withPki(node *Pki) pkiOption {
	return func(m *PkiMutation) {
		m.oldValue = func(context.Context) (*Pki, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PkiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PkiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PkiMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PkiMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pki.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PkiMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PkiMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PkiMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PkiMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PkiMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PkiMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PkiMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PkiMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PkiMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[pki.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PkiMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[pki.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PkiMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, pki.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *PkiMutation) SetType(pk pki.Type) {
	m._type = &pk
}

// GetType returns the value of the "type" field in the mutation.
func (m *PkiMutation) GetType() (r pki.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldType(ctx context.Context) (v pki.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PkiMutation) ResetType() {
	m._type = nil
}

// SetKey sets the "key" field.
func (m *PkiMutation) SetKey(b []byte) {
	m.key = &b
}

// Key returns the value of the "key" field in the mutation.
func (m *PkiMutation) Key() (r []byte, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PkiMutation) ResetKey() {
	m.key = nil
}

// SetCert sets the "cert" field.
func (m *PkiMutation) SetCert(b []byte) {
	m.cert = &b
}

// Cert returns the value of the "cert" field in the mutation.
func (m *PkiMutation) Cert() (r []byte, exists bool) {
	v := m.cert
	if v == nil {
		return
	}
	return *v, true
}

// OldCert returns the old "cert" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldCert(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCert: %w", err)
	}
	return oldValue.Cert, nil
}

// ResetCert resets all changes to the "cert" field.
func (m *PkiMutation) ResetCert() {
	m.cert = nil
}

// Where appends a list predicates to the PkiMutation builder.
func (m *PkiMutation) Where(ps ...predicate.Pki) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PkiMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PkiMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pki, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PkiMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PkiMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pki).
func (m *PkiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PkiMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, pki.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pki.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, pki.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, pki.FieldType)
	}
	if m.key != nil {
		fields = append(fields, pki.FieldKey)
	}
	if m.cert != nil {
		fields = append(fields, pki.FieldCert)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PkiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pki.FieldCreatedAt:
		return m.CreatedAt()
	case pki.FieldUpdatedAt:
		return m.UpdatedAt()
	case pki.FieldDeletedAt:
		return m.DeletedAt()
	case pki.FieldType:
		return m.GetType()
	case pki.FieldKey:
		return m.Key()
	case pki.FieldCert:
		return m.Cert()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PkiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pki.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pki.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pki.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case pki.FieldType:
		return m.OldType(ctx)
	case pki.FieldKey:
		return m.OldKey(ctx)
	case pki.FieldCert:
		return m.OldCert(ctx)
	}
	return nil, fmt.Errorf("unknown Pki field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pki.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pki.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pki.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case pki.FieldType:
		v, ok := value.(pki.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case pki.FieldKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case pki.FieldCert:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCert(v)
		return nil
	}
	return fmt.Errorf("unknown Pki field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PkiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PkiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkiMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pki numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PkiMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pki.FieldDeletedAt) {
		fields = append(fields, pki.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PkiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PkiMutation) ClearField(name string) error {
	switch name {
	case pki.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Pki nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PkiMutation) ResetField(name string) error {
	switch name {
	case pki.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pki.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pki.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case pki.FieldType:
		m.ResetType()
		return nil
	case pki.FieldKey:
		m.ResetKey()
		return nil
	case pki.FieldCert:
		m.ResetCert()
		return nil
	}
	return fmt.Errorf("unknown Pki field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PkiMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PkiMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PkiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PkiMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PkiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PkiMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PkiMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pki unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PkiMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pki edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	pushed_at             *time.Time
	done_at               *time.Time
	status                *defaults.TaskStatus
	cap                   *defaults.Capability
	output_big            *bool
	clearedFields         map[string]struct{}
	group                 *int
	clearedgroup          bool
	beacon                *int
	clearedbeacon         bool
	blobber_args          *int
	clearedblobber_args   bool
	blobber_output        *int
	clearedblobber_output bool
	done                  bool
	oldValue              func(context.Context) (*Task, error)
	predicates            []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGid sets the "gid" field.
func (m *TaskMutation) SetGid(i int) {
	m.group = &i
}

// Gid returns the value of the "gid" field in the mutation.
func (m *TaskMutation) Gid() (r int, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGid returns the old "gid" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldGid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGid: %w", err)
	}
	return oldValue.Gid, nil
}

// ResetGid resets all changes to the "gid" field.
func (m *TaskMutation) ResetGid() {
	m.group = nil
}

// SetBid sets the "bid" field.
func (m *TaskMutation) SetBid(i int) {
	m.beacon = &i
}

// Bid returns the value of the "bid" field in the mutation.
func (m *TaskMutation) Bid() (r int, exists bool) {
	v := m.beacon
	if v == nil {
		return
	}
	return *v, true
}

// OldBid returns the old "bid" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldBid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBid: %w", err)
	}
	return oldValue.Bid, nil
}

// ResetBid resets all changes to the "bid" field.
func (m *TaskMutation) ResetBid() {
	m.beacon = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPushedAt sets the "pushed_at" field.
func (m *TaskMutation) SetPushedAt(t time.Time) {
	m.pushed_at = &t
}

// PushedAt returns the value of the "pushed_at" field in the mutation.
func (m *TaskMutation) PushedAt() (r time.Time, exists bool) {
	v := m.pushed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPushedAt returns the old "pushed_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPushedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushedAt: %w", err)
	}
	return oldValue.PushedAt, nil
}

// ClearPushedAt clears the value of the "pushed_at" field.
func (m *TaskMutation) ClearPushedAt() {
	m.pushed_at = nil
	m.clearedFields[task.FieldPushedAt] = struct{}{}
}

// PushedAtCleared returns if the "pushed_at" field was cleared in this mutation.
func (m *TaskMutation) PushedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldPushedAt]
	return ok
}

// ResetPushedAt resets all changes to the "pushed_at" field.
func (m *TaskMutation) ResetPushedAt() {
	m.pushed_at = nil
	delete(m.clearedFields, task.FieldPushedAt)
}

// SetDoneAt sets the "done_at" field.
func (m *TaskMutation) SetDoneAt(t time.Time) {
	m.done_at = &t
}

// DoneAt returns the value of the "done_at" field in the mutation.
func (m *TaskMutation) DoneAt() (r time.Time, exists bool) {
	v := m.done_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDoneAt returns the old "done_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDoneAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoneAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoneAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoneAt: %w", err)
	}
	return oldValue.DoneAt, nil
}

// ClearDoneAt clears the value of the "done_at" field.
func (m *TaskMutation) ClearDoneAt() {
	m.done_at = nil
	m.clearedFields[task.FieldDoneAt] = struct{}{}
}

// DoneAtCleared returns if the "done_at" field was cleared in this mutation.
func (m *TaskMutation) DoneAtCleared() bool {
	_, ok := m.clearedFields[task.FieldDoneAt]
	return ok
}

// ResetDoneAt resets all changes to the "done_at" field.
func (m *TaskMutation) ResetDoneAt() {
	m.done_at = nil
	delete(m.clearedFields, task.FieldDoneAt)
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(ds defaults.TaskStatus) {
	m.status = &ds
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r defaults.TaskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v defaults.TaskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// SetCap sets the "cap" field.
func (m *TaskMutation) SetCap(d defaults.Capability) {
	m.cap = &d
}

// Cap returns the value of the "cap" field in the mutation.
func (m *TaskMutation) Cap() (r defaults.Capability, exists bool) {
	v := m.cap
	if v == nil {
		return
	}
	return *v, true
}

// OldCap returns the old "cap" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCap(ctx context.Context) (v defaults.Capability, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCap: %w", err)
	}
	return oldValue.Cap, nil
}

// ResetCap resets all changes to the "cap" field.
func (m *TaskMutation) ResetCap() {
	m.cap = nil
}

// SetArgs sets the "args" field.
func (m *TaskMutation) SetArgs(i int) {
	m.blobber_args = &i
}

// Args returns the value of the "args" field in the mutation.
func (m *TaskMutation) Args() (r int, exists bool) {
	v := m.blobber_args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldArgs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ResetArgs resets all changes to the "args" field.
func (m *TaskMutation) ResetArgs() {
	m.blobber_args = nil
}

// SetOutput sets the "output" field.
func (m *TaskMutation) SetOutput(i int) {
	m.blobber_output = &i
}

// Output returns the value of the "output" field in the mutation.
func (m *TaskMutation) Output() (r int, exists bool) {
	v := m.blobber_output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldOutput(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *TaskMutation) ClearOutput() {
	m.blobber_output = nil
	m.clearedFields[task.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *TaskMutation) OutputCleared() bool {
	_, ok := m.clearedFields[task.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *TaskMutation) ResetOutput() {
	m.blobber_output = nil
	delete(m.clearedFields, task.FieldOutput)
}

// SetOutputBig sets the "output_big" field.
func (m *TaskMutation) SetOutputBig(b bool) {
	m.output_big = &b
}

// OutputBig returns the value of the "output_big" field in the mutation.
func (m *TaskMutation) OutputBig() (r bool, exists bool) {
	v := m.output_big
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputBig returns the old "output_big" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldOutputBig(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputBig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputBig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputBig: %w", err)
	}
	return oldValue.OutputBig, nil
}

// ClearOutputBig clears the value of the "output_big" field.
func (m *TaskMutation) ClearOutputBig() {
	m.output_big = nil
	m.clearedFields[task.FieldOutputBig] = struct{}{}
}

// OutputBigCleared returns if the "output_big" field was cleared in this mutation.
func (m *TaskMutation) OutputBigCleared() bool {
	_, ok := m.clearedFields[task.FieldOutputBig]
	return ok
}

// ResetOutputBig resets all changes to the "output_big" field.
func (m *TaskMutation) ResetOutputBig() {
	m.output_big = nil
	delete(m.clearedFields, task.FieldOutputBig)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *TaskMutation) SetGroupID(id int) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *TaskMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[task.FieldGid] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *TaskMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *TaskMutation) GroupID() (id int, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) GroupIDs() (ids []int) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *TaskMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// SetBeaconID sets the "beacon" edge to the Beacon entity by id.
func (m *TaskMutation) SetBeaconID(id int) {
	m.beacon = &id
}

// ClearBeacon clears the "beacon" edge to the Beacon entity.
func (m *TaskMutation) ClearBeacon() {
	m.clearedbeacon = true
	m.clearedFields[task.FieldBid] = struct{}{}
}

// BeaconCleared reports if the "beacon" edge to the Beacon entity was cleared.
func (m *TaskMutation) BeaconCleared() bool {
	return m.clearedbeacon
}

// BeaconID returns the "beacon" edge ID in the mutation.
func (m *TaskMutation) BeaconID() (id int, exists bool) {
	if m.beacon != nil {
		return *m.beacon, true
	}
	return
}

// BeaconIDs returns the "beacon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BeaconID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) BeaconIDs() (ids []int) {
	if id := m.beacon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBeacon resets all changes to the "beacon" edge.
func (m *TaskMutation) ResetBeacon() {
	m.beacon = nil
	m.clearedbeacon = false
}

// SetBlobberArgsID sets the "blobber_args" edge to the Blobber entity by id.
func (m *TaskMutation) SetBlobberArgsID(id int) {
	m.blobber_args = &id
}

// ClearBlobberArgs clears the "blobber_args" edge to the Blobber entity.
func (m *TaskMutation) ClearBlobberArgs() {
	m.clearedblobber_args = true
	m.clearedFields[task.FieldArgs] = struct{}{}
}

// BlobberArgsCleared reports if the "blobber_args" edge to the Blobber entity was cleared.
func (m *TaskMutation) BlobberArgsCleared() bool {
	return m.clearedblobber_args
}

// BlobberArgsID returns the "blobber_args" edge ID in the mutation.
func (m *TaskMutation) BlobberArgsID() (id int, exists bool) {
	if m.blobber_args != nil {
		return *m.blobber_args, true
	}
	return
}

// BlobberArgsIDs returns the "blobber_args" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlobberArgsID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) BlobberArgsIDs() (ids []int) {
	if id := m.blobber_args; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlobberArgs resets all changes to the "blobber_args" edge.
func (m *TaskMutation) ResetBlobberArgs() {
	m.blobber_args = nil
	m.clearedblobber_args = false
}

// SetBlobberOutputID sets the "blobber_output" edge to the Blobber entity by id.
func (m *TaskMutation) SetBlobberOutputID(id int) {
	m.blobber_output = &id
}

// ClearBlobberOutput clears the "blobber_output" edge to the Blobber entity.
func (m *TaskMutation) ClearBlobberOutput() {
	m.clearedblobber_output = true
	m.clearedFields[task.FieldOutput] = struct{}{}
}

// BlobberOutputCleared reports if the "blobber_output" edge to the Blobber entity was cleared.
func (m *TaskMutation) BlobberOutputCleared() bool {
	return m.OutputCleared() || m.clearedblobber_output
}

// BlobberOutputID returns the "blobber_output" edge ID in the mutation.
func (m *TaskMutation) BlobberOutputID() (id int, exists bool) {
	if m.blobber_output != nil {
		return *m.blobber_output, true
	}
	return
}

// BlobberOutputIDs returns the "blobber_output" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlobberOutputID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) BlobberOutputIDs() (ids []int) {
	if id := m.blobber_output; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlobberOutput resets all changes to the "blobber_output" edge.
func (m *TaskMutation) ResetBlobberOutput() {
	m.blobber_output = nil
	m.clearedblobber_output = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.group != nil {
		fields = append(fields, task.FieldGid)
	}
	if m.beacon != nil {
		fields = append(fields, task.FieldBid)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.pushed_at != nil {
		fields = append(fields, task.FieldPushedAt)
	}
	if m.done_at != nil {
		fields = append(fields, task.FieldDoneAt)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.cap != nil {
		fields = append(fields, task.FieldCap)
	}
	if m.blobber_args != nil {
		fields = append(fields, task.FieldArgs)
	}
	if m.blobber_output != nil {
		fields = append(fields, task.FieldOutput)
	}
	if m.output_big != nil {
		fields = append(fields, task.FieldOutputBig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldGid:
		return m.Gid()
	case task.FieldBid:
		return m.Bid()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldPushedAt:
		return m.PushedAt()
	case task.FieldDoneAt:
		return m.DoneAt()
	case task.FieldStatus:
		return m.Status()
	case task.FieldCap:
		return m.Cap()
	case task.FieldArgs:
		return m.Args()
	case task.FieldOutput:
		return m.Output()
	case task.FieldOutputBig:
		return m.OutputBig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldGid:
		return m.OldGid(ctx)
	case task.FieldBid:
		return m.OldBid(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldPushedAt:
		return m.OldPushedAt(ctx)
	case task.FieldDoneAt:
		return m.OldDoneAt(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldCap:
		return m.OldCap(ctx)
	case task.FieldArgs:
		return m.OldArgs(ctx)
	case task.FieldOutput:
		return m.OldOutput(ctx)
	case task.FieldOutputBig:
		return m.OldOutputBig(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldGid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGid(v)
		return nil
	case task.FieldBid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBid(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldPushedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushedAt(v)
		return nil
	case task.FieldDoneAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoneAt(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(defaults.TaskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldCap:
		v, ok := value.(defaults.Capability)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCap(v)
		return nil
	case task.FieldArgs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case task.FieldOutput:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case task.FieldOutputBig:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputBig(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldPushedAt) {
		fields = append(fields, task.FieldPushedAt)
	}
	if m.FieldCleared(task.FieldDoneAt) {
		fields = append(fields, task.FieldDoneAt)
	}
	if m.FieldCleared(task.FieldOutput) {
		fields = append(fields, task.FieldOutput)
	}
	if m.FieldCleared(task.FieldOutputBig) {
		fields = append(fields, task.FieldOutputBig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldPushedAt:
		m.ClearPushedAt()
		return nil
	case task.FieldDoneAt:
		m.ClearDoneAt()
		return nil
	case task.FieldOutput:
		m.ClearOutput()
		return nil
	case task.FieldOutputBig:
		m.ClearOutputBig()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldGid:
		m.ResetGid()
		return nil
	case task.FieldBid:
		m.ResetBid()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldPushedAt:
		m.ResetPushedAt()
		return nil
	case task.FieldDoneAt:
		m.ResetDoneAt()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldCap:
		m.ResetCap()
		return nil
	case task.FieldArgs:
		m.ResetArgs()
		return nil
	case task.FieldOutput:
		m.ResetOutput()
		return nil
	case task.FieldOutputBig:
		m.ResetOutputBig()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.group != nil {
		edges = append(edges, task.EdgeGroup)
	}
	if m.beacon != nil {
		edges = append(edges, task.EdgeBeacon)
	}
	if m.blobber_args != nil {
		edges = append(edges, task.EdgeBlobberArgs)
	}
	if m.blobber_output != nil {
		edges = append(edges, task.EdgeBlobberOutput)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeBeacon:
		if id := m.beacon; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeBlobberArgs:
		if id := m.blobber_args; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeBlobberOutput:
		if id := m.blobber_output; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedgroup {
		edges = append(edges, task.EdgeGroup)
	}
	if m.clearedbeacon {
		edges = append(edges, task.EdgeBeacon)
	}
	if m.clearedblobber_args {
		edges = append(edges, task.EdgeBlobberArgs)
	}
	if m.clearedblobber_output {
		edges = append(edges, task.EdgeBlobberOutput)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeGroup:
		return m.clearedgroup
	case task.EdgeBeacon:
		return m.clearedbeacon
	case task.EdgeBlobberArgs:
		return m.clearedblobber_args
	case task.EdgeBlobberOutput:
		return m.clearedblobber_output
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeGroup:
		m.ClearGroup()
		return nil
	case task.EdgeBeacon:
		m.ClearBeacon()
		return nil
	case task.EdgeBlobberArgs:
		m.ClearBlobberArgs()
		return nil
	case task.EdgeBlobberOutput:
		m.ClearBlobberOutput()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeGroup:
		m.ResetGroup()
		return nil
	case task.EdgeBeacon:
		m.ResetBeacon()
		return nil
	case task.EdgeBlobberArgs:
		m.ResetBlobberArgs()
		return nil
	case task.EdgeBlobberOutput:
		m.ResetBlobberOutput()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}
