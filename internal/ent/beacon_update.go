// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/c2micro/c2msrv/internal/ent/beacon"
	"github.com/c2micro/c2msrv/internal/ent/group"
	"github.com/c2micro/c2msrv/internal/ent/listener"
	"github.com/c2micro/c2msrv/internal/ent/predicate"
	"github.com/c2micro/c2msrv/internal/ent/task"
	"github.com/c2micro/c2msrv/internal/types"
	"github.com/c2micro/c2mshr/defaults"
)

// BeaconUpdate is the builder for updating Beacon entities.
type BeaconUpdate struct {
	config
	hooks    []Hook
	mutation *BeaconMutation
}

// Where appends a list predicates to the BeaconUpdate builder.
func (bu *BeaconUpdate) Where(ps ...predicate.Beacon) *BeaconUpdate {
	bu.mutation.Where(ps...)
	return bu
}

// SetUpdatedAt sets the "updated_at" field.
func (bu *BeaconUpdate) SetUpdatedAt(t time.Time) *BeaconUpdate {
	bu.mutation.SetUpdatedAt(t)
	return bu
}

// SetDeletedAt sets the "deleted_at" field.
func (bu *BeaconUpdate) SetDeletedAt(t time.Time) *BeaconUpdate {
	bu.mutation.SetDeletedAt(t)
	return bu
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableDeletedAt(t *time.Time) *BeaconUpdate {
	if t != nil {
		bu.SetDeletedAt(*t)
	}
	return bu
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (bu *BeaconUpdate) ClearDeletedAt() *BeaconUpdate {
	bu.mutation.ClearDeletedAt()
	return bu
}

// SetBid sets the "bid" field.
func (bu *BeaconUpdate) SetBid(u uint32) *BeaconUpdate {
	bu.mutation.ResetBid()
	bu.mutation.SetBid(u)
	return bu
}

// SetNillableBid sets the "bid" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableBid(u *uint32) *BeaconUpdate {
	if u != nil {
		bu.SetBid(*u)
	}
	return bu
}

// AddBid adds u to the "bid" field.
func (bu *BeaconUpdate) AddBid(u int32) *BeaconUpdate {
	bu.mutation.AddBid(u)
	return bu
}

// SetListenerID sets the "listener_id" field.
func (bu *BeaconUpdate) SetListenerID(i int) *BeaconUpdate {
	bu.mutation.SetListenerID(i)
	return bu
}

// SetNillableListenerID sets the "listener_id" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableListenerID(i *int) *BeaconUpdate {
	if i != nil {
		bu.SetListenerID(*i)
	}
	return bu
}

// SetExtIP sets the "ext_ip" field.
func (bu *BeaconUpdate) SetExtIP(t types.Inet) *BeaconUpdate {
	bu.mutation.SetExtIP(t)
	return bu
}

// SetNillableExtIP sets the "ext_ip" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableExtIP(t *types.Inet) *BeaconUpdate {
	if t != nil {
		bu.SetExtIP(*t)
	}
	return bu
}

// ClearExtIP clears the value of the "ext_ip" field.
func (bu *BeaconUpdate) ClearExtIP() *BeaconUpdate {
	bu.mutation.ClearExtIP()
	return bu
}

// SetIntIP sets the "int_ip" field.
func (bu *BeaconUpdate) SetIntIP(t types.Inet) *BeaconUpdate {
	bu.mutation.SetIntIP(t)
	return bu
}

// SetNillableIntIP sets the "int_ip" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableIntIP(t *types.Inet) *BeaconUpdate {
	if t != nil {
		bu.SetIntIP(*t)
	}
	return bu
}

// ClearIntIP clears the value of the "int_ip" field.
func (bu *BeaconUpdate) ClearIntIP() *BeaconUpdate {
	bu.mutation.ClearIntIP()
	return bu
}

// SetOs sets the "os" field.
func (bu *BeaconUpdate) SetOs(do defaults.BeaconOS) *BeaconUpdate {
	bu.mutation.SetOs(do)
	return bu
}

// SetNillableOs sets the "os" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableOs(do *defaults.BeaconOS) *BeaconUpdate {
	if do != nil {
		bu.SetOs(*do)
	}
	return bu
}

// SetOsMeta sets the "os_meta" field.
func (bu *BeaconUpdate) SetOsMeta(s string) *BeaconUpdate {
	bu.mutation.SetOsMeta(s)
	return bu
}

// SetNillableOsMeta sets the "os_meta" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableOsMeta(s *string) *BeaconUpdate {
	if s != nil {
		bu.SetOsMeta(*s)
	}
	return bu
}

// ClearOsMeta clears the value of the "os_meta" field.
func (bu *BeaconUpdate) ClearOsMeta() *BeaconUpdate {
	bu.mutation.ClearOsMeta()
	return bu
}

// SetHostname sets the "hostname" field.
func (bu *BeaconUpdate) SetHostname(s string) *BeaconUpdate {
	bu.mutation.SetHostname(s)
	return bu
}

// SetNillableHostname sets the "hostname" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableHostname(s *string) *BeaconUpdate {
	if s != nil {
		bu.SetHostname(*s)
	}
	return bu
}

// ClearHostname clears the value of the "hostname" field.
func (bu *BeaconUpdate) ClearHostname() *BeaconUpdate {
	bu.mutation.ClearHostname()
	return bu
}

// SetUsername sets the "username" field.
func (bu *BeaconUpdate) SetUsername(s string) *BeaconUpdate {
	bu.mutation.SetUsername(s)
	return bu
}

// SetNillableUsername sets the "username" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableUsername(s *string) *BeaconUpdate {
	if s != nil {
		bu.SetUsername(*s)
	}
	return bu
}

// ClearUsername clears the value of the "username" field.
func (bu *BeaconUpdate) ClearUsername() *BeaconUpdate {
	bu.mutation.ClearUsername()
	return bu
}

// SetDomain sets the "domain" field.
func (bu *BeaconUpdate) SetDomain(s string) *BeaconUpdate {
	bu.mutation.SetDomain(s)
	return bu
}

// SetNillableDomain sets the "domain" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableDomain(s *string) *BeaconUpdate {
	if s != nil {
		bu.SetDomain(*s)
	}
	return bu
}

// ClearDomain clears the value of the "domain" field.
func (bu *BeaconUpdate) ClearDomain() *BeaconUpdate {
	bu.mutation.ClearDomain()
	return bu
}

// SetPrivileged sets the "privileged" field.
func (bu *BeaconUpdate) SetPrivileged(b bool) *BeaconUpdate {
	bu.mutation.SetPrivileged(b)
	return bu
}

// SetNillablePrivileged sets the "privileged" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillablePrivileged(b *bool) *BeaconUpdate {
	if b != nil {
		bu.SetPrivileged(*b)
	}
	return bu
}

// ClearPrivileged clears the value of the "privileged" field.
func (bu *BeaconUpdate) ClearPrivileged() *BeaconUpdate {
	bu.mutation.ClearPrivileged()
	return bu
}

// SetProcessName sets the "process_name" field.
func (bu *BeaconUpdate) SetProcessName(s string) *BeaconUpdate {
	bu.mutation.SetProcessName(s)
	return bu
}

// SetNillableProcessName sets the "process_name" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableProcessName(s *string) *BeaconUpdate {
	if s != nil {
		bu.SetProcessName(*s)
	}
	return bu
}

// ClearProcessName clears the value of the "process_name" field.
func (bu *BeaconUpdate) ClearProcessName() *BeaconUpdate {
	bu.mutation.ClearProcessName()
	return bu
}

// SetPid sets the "pid" field.
func (bu *BeaconUpdate) SetPid(u uint32) *BeaconUpdate {
	bu.mutation.ResetPid()
	bu.mutation.SetPid(u)
	return bu
}

// SetNillablePid sets the "pid" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillablePid(u *uint32) *BeaconUpdate {
	if u != nil {
		bu.SetPid(*u)
	}
	return bu
}

// AddPid adds u to the "pid" field.
func (bu *BeaconUpdate) AddPid(u int32) *BeaconUpdate {
	bu.mutation.AddPid(u)
	return bu
}

// ClearPid clears the value of the "pid" field.
func (bu *BeaconUpdate) ClearPid() *BeaconUpdate {
	bu.mutation.ClearPid()
	return bu
}

// SetArch sets the "arch" field.
func (bu *BeaconUpdate) SetArch(da defaults.BeaconArch) *BeaconUpdate {
	bu.mutation.SetArch(da)
	return bu
}

// SetNillableArch sets the "arch" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableArch(da *defaults.BeaconArch) *BeaconUpdate {
	if da != nil {
		bu.SetArch(*da)
	}
	return bu
}

// SetSleep sets the "sleep" field.
func (bu *BeaconUpdate) SetSleep(u uint32) *BeaconUpdate {
	bu.mutation.ResetSleep()
	bu.mutation.SetSleep(u)
	return bu
}

// SetNillableSleep sets the "sleep" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableSleep(u *uint32) *BeaconUpdate {
	if u != nil {
		bu.SetSleep(*u)
	}
	return bu
}

// AddSleep adds u to the "sleep" field.
func (bu *BeaconUpdate) AddSleep(u int32) *BeaconUpdate {
	bu.mutation.AddSleep(u)
	return bu
}

// SetJitter sets the "jitter" field.
func (bu *BeaconUpdate) SetJitter(u uint8) *BeaconUpdate {
	bu.mutation.ResetJitter()
	bu.mutation.SetJitter(u)
	return bu
}

// SetNillableJitter sets the "jitter" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableJitter(u *uint8) *BeaconUpdate {
	if u != nil {
		bu.SetJitter(*u)
	}
	return bu
}

// AddJitter adds u to the "jitter" field.
func (bu *BeaconUpdate) AddJitter(u int8) *BeaconUpdate {
	bu.mutation.AddJitter(u)
	return bu
}

// SetFirst sets the "first" field.
func (bu *BeaconUpdate) SetFirst(t time.Time) *BeaconUpdate {
	bu.mutation.SetFirst(t)
	return bu
}

// SetNillableFirst sets the "first" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableFirst(t *time.Time) *BeaconUpdate {
	if t != nil {
		bu.SetFirst(*t)
	}
	return bu
}

// SetLast sets the "last" field.
func (bu *BeaconUpdate) SetLast(t time.Time) *BeaconUpdate {
	bu.mutation.SetLast(t)
	return bu
}

// SetNillableLast sets the "last" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableLast(t *time.Time) *BeaconUpdate {
	if t != nil {
		bu.SetLast(*t)
	}
	return bu
}

// SetCaps sets the "caps" field.
func (bu *BeaconUpdate) SetCaps(u uint32) *BeaconUpdate {
	bu.mutation.ResetCaps()
	bu.mutation.SetCaps(u)
	return bu
}

// SetNillableCaps sets the "caps" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableCaps(u *uint32) *BeaconUpdate {
	if u != nil {
		bu.SetCaps(*u)
	}
	return bu
}

// AddCaps adds u to the "caps" field.
func (bu *BeaconUpdate) AddCaps(u int32) *BeaconUpdate {
	bu.mutation.AddCaps(u)
	return bu
}

// SetNote sets the "note" field.
func (bu *BeaconUpdate) SetNote(s string) *BeaconUpdate {
	bu.mutation.SetNote(s)
	return bu
}

// SetNillableNote sets the "note" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableNote(s *string) *BeaconUpdate {
	if s != nil {
		bu.SetNote(*s)
	}
	return bu
}

// ClearNote clears the value of the "note" field.
func (bu *BeaconUpdate) ClearNote() *BeaconUpdate {
	bu.mutation.ClearNote()
	return bu
}

// SetColor sets the "color" field.
func (bu *BeaconUpdate) SetColor(u uint32) *BeaconUpdate {
	bu.mutation.ResetColor()
	bu.mutation.SetColor(u)
	return bu
}

// SetNillableColor sets the "color" field if the given value is not nil.
func (bu *BeaconUpdate) SetNillableColor(u *uint32) *BeaconUpdate {
	if u != nil {
		bu.SetColor(*u)
	}
	return bu
}

// AddColor adds u to the "color" field.
func (bu *BeaconUpdate) AddColor(u int32) *BeaconUpdate {
	bu.mutation.AddColor(u)
	return bu
}

// SetListener sets the "listener" edge to the Listener entity.
func (bu *BeaconUpdate) SetListener(l *Listener) *BeaconUpdate {
	return bu.SetListenerID(l.ID)
}

// AddGroupIDs adds the "group" edge to the Group entity by IDs.
func (bu *BeaconUpdate) AddGroupIDs(ids ...int) *BeaconUpdate {
	bu.mutation.AddGroupIDs(ids...)
	return bu
}

// AddGroup adds the "group" edges to the Group entity.
func (bu *BeaconUpdate) AddGroup(g ...*Group) *BeaconUpdate {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return bu.AddGroupIDs(ids...)
}

// AddTaskIDs adds the "task" edge to the Task entity by IDs.
func (bu *BeaconUpdate) AddTaskIDs(ids ...int) *BeaconUpdate {
	bu.mutation.AddTaskIDs(ids...)
	return bu
}

// AddTask adds the "task" edges to the Task entity.
func (bu *BeaconUpdate) AddTask(t ...*Task) *BeaconUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return bu.AddTaskIDs(ids...)
}

// Mutation returns the BeaconMutation object of the builder.
func (bu *BeaconUpdate) Mutation() *BeaconMutation {
	return bu.mutation
}

// ClearListener clears the "listener" edge to the Listener entity.
func (bu *BeaconUpdate) ClearListener() *BeaconUpdate {
	bu.mutation.ClearListener()
	return bu
}

// ClearGroup clears all "group" edges to the Group entity.
func (bu *BeaconUpdate) ClearGroup() *BeaconUpdate {
	bu.mutation.ClearGroup()
	return bu
}

// RemoveGroupIDs removes the "group" edge to Group entities by IDs.
func (bu *BeaconUpdate) RemoveGroupIDs(ids ...int) *BeaconUpdate {
	bu.mutation.RemoveGroupIDs(ids...)
	return bu
}

// RemoveGroup removes "group" edges to Group entities.
func (bu *BeaconUpdate) RemoveGroup(g ...*Group) *BeaconUpdate {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return bu.RemoveGroupIDs(ids...)
}

// ClearTask clears all "task" edges to the Task entity.
func (bu *BeaconUpdate) ClearTask() *BeaconUpdate {
	bu.mutation.ClearTask()
	return bu
}

// RemoveTaskIDs removes the "task" edge to Task entities by IDs.
func (bu *BeaconUpdate) RemoveTaskIDs(ids ...int) *BeaconUpdate {
	bu.mutation.RemoveTaskIDs(ids...)
	return bu
}

// RemoveTask removes "task" edges to Task entities.
func (bu *BeaconUpdate) RemoveTask(t ...*Task) *BeaconUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return bu.RemoveTaskIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (bu *BeaconUpdate) Save(ctx context.Context) (int, error) {
	if err := bu.defaults(); err != nil {
		return 0, err
	}
	return withHooks(ctx, bu.sqlSave, bu.mutation, bu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (bu *BeaconUpdate) SaveX(ctx context.Context) int {
	affected, err := bu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (bu *BeaconUpdate) Exec(ctx context.Context) error {
	_, err := bu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (bu *BeaconUpdate) ExecX(ctx context.Context) {
	if err := bu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (bu *BeaconUpdate) defaults() error {
	if _, ok := bu.mutation.UpdatedAt(); !ok {
		if beacon.UpdateDefaultUpdatedAt == nil {
			return fmt.Errorf("ent: uninitialized beacon.UpdateDefaultUpdatedAt (forgotten import ent/runtime?)")
		}
		v := beacon.UpdateDefaultUpdatedAt()
		bu.mutation.SetUpdatedAt(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (bu *BeaconUpdate) check() error {
	if v, ok := bu.mutation.ExtIP(); ok {
		if err := beacon.ExtIPValidator(v.String()); err != nil {
			return &ValidationError{Name: "ext_ip", err: fmt.Errorf(`ent: validator failed for field "Beacon.ext_ip": %w`, err)}
		}
	}
	if v, ok := bu.mutation.IntIP(); ok {
		if err := beacon.IntIPValidator(v.String()); err != nil {
			return &ValidationError{Name: "int_ip", err: fmt.Errorf(`ent: validator failed for field "Beacon.int_ip": %w`, err)}
		}
	}
	if v, ok := bu.mutation.Os(); ok {
		if err := beacon.OsValidator(v); err != nil {
			return &ValidationError{Name: "os", err: fmt.Errorf(`ent: validator failed for field "Beacon.os": %w`, err)}
		}
	}
	if v, ok := bu.mutation.OsMeta(); ok {
		if err := beacon.OsMetaValidator(v); err != nil {
			return &ValidationError{Name: "os_meta", err: fmt.Errorf(`ent: validator failed for field "Beacon.os_meta": %w`, err)}
		}
	}
	if v, ok := bu.mutation.Hostname(); ok {
		if err := beacon.HostnameValidator(v); err != nil {
			return &ValidationError{Name: "hostname", err: fmt.Errorf(`ent: validator failed for field "Beacon.hostname": %w`, err)}
		}
	}
	if v, ok := bu.mutation.Username(); ok {
		if err := beacon.UsernameValidator(v); err != nil {
			return &ValidationError{Name: "username", err: fmt.Errorf(`ent: validator failed for field "Beacon.username": %w`, err)}
		}
	}
	if v, ok := bu.mutation.Domain(); ok {
		if err := beacon.DomainValidator(v); err != nil {
			return &ValidationError{Name: "domain", err: fmt.Errorf(`ent: validator failed for field "Beacon.domain": %w`, err)}
		}
	}
	if v, ok := bu.mutation.ProcessName(); ok {
		if err := beacon.ProcessNameValidator(v); err != nil {
			return &ValidationError{Name: "process_name", err: fmt.Errorf(`ent: validator failed for field "Beacon.process_name": %w`, err)}
		}
	}
	if v, ok := bu.mutation.Arch(); ok {
		if err := beacon.ArchValidator(v); err != nil {
			return &ValidationError{Name: "arch", err: fmt.Errorf(`ent: validator failed for field "Beacon.arch": %w`, err)}
		}
	}
	if v, ok := bu.mutation.Note(); ok {
		if err := beacon.NoteValidator(v); err != nil {
			return &ValidationError{Name: "note", err: fmt.Errorf(`ent: validator failed for field "Beacon.note": %w`, err)}
		}
	}
	if bu.mutation.ListenerCleared() && len(bu.mutation.ListenerIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Beacon.listener"`)
	}
	return nil
}

func (bu *BeaconUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := bu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(beacon.Table, beacon.Columns, sqlgraph.NewFieldSpec(beacon.FieldID, field.TypeInt))
	if ps := bu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := bu.mutation.UpdatedAt(); ok {
		_spec.SetField(beacon.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := bu.mutation.DeletedAt(); ok {
		_spec.SetField(beacon.FieldDeletedAt, field.TypeTime, value)
	}
	if bu.mutation.DeletedAtCleared() {
		_spec.ClearField(beacon.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := bu.mutation.Bid(); ok {
		_spec.SetField(beacon.FieldBid, field.TypeUint32, value)
	}
	if value, ok := bu.mutation.AddedBid(); ok {
		_spec.AddField(beacon.FieldBid, field.TypeUint32, value)
	}
	if value, ok := bu.mutation.ExtIP(); ok {
		_spec.SetField(beacon.FieldExtIP, field.TypeString, value)
	}
	if bu.mutation.ExtIPCleared() {
		_spec.ClearField(beacon.FieldExtIP, field.TypeString)
	}
	if value, ok := bu.mutation.IntIP(); ok {
		_spec.SetField(beacon.FieldIntIP, field.TypeString, value)
	}
	if bu.mutation.IntIPCleared() {
		_spec.ClearField(beacon.FieldIntIP, field.TypeString)
	}
	if value, ok := bu.mutation.Os(); ok {
		_spec.SetField(beacon.FieldOs, field.TypeEnum, value)
	}
	if value, ok := bu.mutation.OsMeta(); ok {
		_spec.SetField(beacon.FieldOsMeta, field.TypeString, value)
	}
	if bu.mutation.OsMetaCleared() {
		_spec.ClearField(beacon.FieldOsMeta, field.TypeString)
	}
	if value, ok := bu.mutation.Hostname(); ok {
		_spec.SetField(beacon.FieldHostname, field.TypeString, value)
	}
	if bu.mutation.HostnameCleared() {
		_spec.ClearField(beacon.FieldHostname, field.TypeString)
	}
	if value, ok := bu.mutation.Username(); ok {
		_spec.SetField(beacon.FieldUsername, field.TypeString, value)
	}
	if bu.mutation.UsernameCleared() {
		_spec.ClearField(beacon.FieldUsername, field.TypeString)
	}
	if value, ok := bu.mutation.Domain(); ok {
		_spec.SetField(beacon.FieldDomain, field.TypeString, value)
	}
	if bu.mutation.DomainCleared() {
		_spec.ClearField(beacon.FieldDomain, field.TypeString)
	}
	if value, ok := bu.mutation.Privileged(); ok {
		_spec.SetField(beacon.FieldPrivileged, field.TypeBool, value)
	}
	if bu.mutation.PrivilegedCleared() {
		_spec.ClearField(beacon.FieldPrivileged, field.TypeBool)
	}
	if value, ok := bu.mutation.ProcessName(); ok {
		_spec.SetField(beacon.FieldProcessName, field.TypeString, value)
	}
	if bu.mutation.ProcessNameCleared() {
		_spec.ClearField(beacon.FieldProcessName, field.TypeString)
	}
	if value, ok := bu.mutation.Pid(); ok {
		_spec.SetField(beacon.FieldPid, field.TypeUint32, value)
	}
	if value, ok := bu.mutation.AddedPid(); ok {
		_spec.AddField(beacon.FieldPid, field.TypeUint32, value)
	}
	if bu.mutation.PidCleared() {
		_spec.ClearField(beacon.FieldPid, field.TypeUint32)
	}
	if value, ok := bu.mutation.Arch(); ok {
		_spec.SetField(beacon.FieldArch, field.TypeEnum, value)
	}
	if value, ok := bu.mutation.Sleep(); ok {
		_spec.SetField(beacon.FieldSleep, field.TypeUint32, value)
	}
	if value, ok := bu.mutation.AddedSleep(); ok {
		_spec.AddField(beacon.FieldSleep, field.TypeUint32, value)
	}
	if value, ok := bu.mutation.Jitter(); ok {
		_spec.SetField(beacon.FieldJitter, field.TypeUint8, value)
	}
	if value, ok := bu.mutation.AddedJitter(); ok {
		_spec.AddField(beacon.FieldJitter, field.TypeUint8, value)
	}
	if value, ok := bu.mutation.First(); ok {
		_spec.SetField(beacon.FieldFirst, field.TypeTime, value)
	}
	if value, ok := bu.mutation.Last(); ok {
		_spec.SetField(beacon.FieldLast, field.TypeTime, value)
	}
	if value, ok := bu.mutation.Caps(); ok {
		_spec.SetField(beacon.FieldCaps, field.TypeUint32, value)
	}
	if value, ok := bu.mutation.AddedCaps(); ok {
		_spec.AddField(beacon.FieldCaps, field.TypeUint32, value)
	}
	if value, ok := bu.mutation.Note(); ok {
		_spec.SetField(beacon.FieldNote, field.TypeString, value)
	}
	if bu.mutation.NoteCleared() {
		_spec.ClearField(beacon.FieldNote, field.TypeString)
	}
	if value, ok := bu.mutation.Color(); ok {
		_spec.SetField(beacon.FieldColor, field.TypeUint32, value)
	}
	if value, ok := bu.mutation.AddedColor(); ok {
		_spec.AddField(beacon.FieldColor, field.TypeUint32, value)
	}
	if bu.mutation.ListenerCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   beacon.ListenerTable,
			Columns: []string{beacon.ListenerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(listener.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := bu.mutation.ListenerIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   beacon.ListenerTable,
			Columns: []string{beacon.ListenerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(listener.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if bu.mutation.GroupCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.GroupTable,
			Columns: []string{beacon.GroupColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(group.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := bu.mutation.RemovedGroupIDs(); len(nodes) > 0 && !bu.mutation.GroupCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.GroupTable,
			Columns: []string{beacon.GroupColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(group.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := bu.mutation.GroupIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.GroupTable,
			Columns: []string{beacon.GroupColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(group.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if bu.mutation.TaskCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.TaskTable,
			Columns: []string{beacon.TaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := bu.mutation.RemovedTaskIDs(); len(nodes) > 0 && !bu.mutation.TaskCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.TaskTable,
			Columns: []string{beacon.TaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := bu.mutation.TaskIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.TaskTable,
			Columns: []string{beacon.TaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, bu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{beacon.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	bu.mutation.done = true
	return n, nil
}

// BeaconUpdateOne is the builder for updating a single Beacon entity.
type BeaconUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *BeaconMutation
}

// SetUpdatedAt sets the "updated_at" field.
func (buo *BeaconUpdateOne) SetUpdatedAt(t time.Time) *BeaconUpdateOne {
	buo.mutation.SetUpdatedAt(t)
	return buo
}

// SetDeletedAt sets the "deleted_at" field.
func (buo *BeaconUpdateOne) SetDeletedAt(t time.Time) *BeaconUpdateOne {
	buo.mutation.SetDeletedAt(t)
	return buo
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableDeletedAt(t *time.Time) *BeaconUpdateOne {
	if t != nil {
		buo.SetDeletedAt(*t)
	}
	return buo
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (buo *BeaconUpdateOne) ClearDeletedAt() *BeaconUpdateOne {
	buo.mutation.ClearDeletedAt()
	return buo
}

// SetBid sets the "bid" field.
func (buo *BeaconUpdateOne) SetBid(u uint32) *BeaconUpdateOne {
	buo.mutation.ResetBid()
	buo.mutation.SetBid(u)
	return buo
}

// SetNillableBid sets the "bid" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableBid(u *uint32) *BeaconUpdateOne {
	if u != nil {
		buo.SetBid(*u)
	}
	return buo
}

// AddBid adds u to the "bid" field.
func (buo *BeaconUpdateOne) AddBid(u int32) *BeaconUpdateOne {
	buo.mutation.AddBid(u)
	return buo
}

// SetListenerID sets the "listener_id" field.
func (buo *BeaconUpdateOne) SetListenerID(i int) *BeaconUpdateOne {
	buo.mutation.SetListenerID(i)
	return buo
}

// SetNillableListenerID sets the "listener_id" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableListenerID(i *int) *BeaconUpdateOne {
	if i != nil {
		buo.SetListenerID(*i)
	}
	return buo
}

// SetExtIP sets the "ext_ip" field.
func (buo *BeaconUpdateOne) SetExtIP(t types.Inet) *BeaconUpdateOne {
	buo.mutation.SetExtIP(t)
	return buo
}

// SetNillableExtIP sets the "ext_ip" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableExtIP(t *types.Inet) *BeaconUpdateOne {
	if t != nil {
		buo.SetExtIP(*t)
	}
	return buo
}

// ClearExtIP clears the value of the "ext_ip" field.
func (buo *BeaconUpdateOne) ClearExtIP() *BeaconUpdateOne {
	buo.mutation.ClearExtIP()
	return buo
}

// SetIntIP sets the "int_ip" field.
func (buo *BeaconUpdateOne) SetIntIP(t types.Inet) *BeaconUpdateOne {
	buo.mutation.SetIntIP(t)
	return buo
}

// SetNillableIntIP sets the "int_ip" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableIntIP(t *types.Inet) *BeaconUpdateOne {
	if t != nil {
		buo.SetIntIP(*t)
	}
	return buo
}

// ClearIntIP clears the value of the "int_ip" field.
func (buo *BeaconUpdateOne) ClearIntIP() *BeaconUpdateOne {
	buo.mutation.ClearIntIP()
	return buo
}

// SetOs sets the "os" field.
func (buo *BeaconUpdateOne) SetOs(do defaults.BeaconOS) *BeaconUpdateOne {
	buo.mutation.SetOs(do)
	return buo
}

// SetNillableOs sets the "os" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableOs(do *defaults.BeaconOS) *BeaconUpdateOne {
	if do != nil {
		buo.SetOs(*do)
	}
	return buo
}

// SetOsMeta sets the "os_meta" field.
func (buo *BeaconUpdateOne) SetOsMeta(s string) *BeaconUpdateOne {
	buo.mutation.SetOsMeta(s)
	return buo
}

// SetNillableOsMeta sets the "os_meta" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableOsMeta(s *string) *BeaconUpdateOne {
	if s != nil {
		buo.SetOsMeta(*s)
	}
	return buo
}

// ClearOsMeta clears the value of the "os_meta" field.
func (buo *BeaconUpdateOne) ClearOsMeta() *BeaconUpdateOne {
	buo.mutation.ClearOsMeta()
	return buo
}

// SetHostname sets the "hostname" field.
func (buo *BeaconUpdateOne) SetHostname(s string) *BeaconUpdateOne {
	buo.mutation.SetHostname(s)
	return buo
}

// SetNillableHostname sets the "hostname" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableHostname(s *string) *BeaconUpdateOne {
	if s != nil {
		buo.SetHostname(*s)
	}
	return buo
}

// ClearHostname clears the value of the "hostname" field.
func (buo *BeaconUpdateOne) ClearHostname() *BeaconUpdateOne {
	buo.mutation.ClearHostname()
	return buo
}

// SetUsername sets the "username" field.
func (buo *BeaconUpdateOne) SetUsername(s string) *BeaconUpdateOne {
	buo.mutation.SetUsername(s)
	return buo
}

// SetNillableUsername sets the "username" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableUsername(s *string) *BeaconUpdateOne {
	if s != nil {
		buo.SetUsername(*s)
	}
	return buo
}

// ClearUsername clears the value of the "username" field.
func (buo *BeaconUpdateOne) ClearUsername() *BeaconUpdateOne {
	buo.mutation.ClearUsername()
	return buo
}

// SetDomain sets the "domain" field.
func (buo *BeaconUpdateOne) SetDomain(s string) *BeaconUpdateOne {
	buo.mutation.SetDomain(s)
	return buo
}

// SetNillableDomain sets the "domain" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableDomain(s *string) *BeaconUpdateOne {
	if s != nil {
		buo.SetDomain(*s)
	}
	return buo
}

// ClearDomain clears the value of the "domain" field.
func (buo *BeaconUpdateOne) ClearDomain() *BeaconUpdateOne {
	buo.mutation.ClearDomain()
	return buo
}

// SetPrivileged sets the "privileged" field.
func (buo *BeaconUpdateOne) SetPrivileged(b bool) *BeaconUpdateOne {
	buo.mutation.SetPrivileged(b)
	return buo
}

// SetNillablePrivileged sets the "privileged" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillablePrivileged(b *bool) *BeaconUpdateOne {
	if b != nil {
		buo.SetPrivileged(*b)
	}
	return buo
}

// ClearPrivileged clears the value of the "privileged" field.
func (buo *BeaconUpdateOne) ClearPrivileged() *BeaconUpdateOne {
	buo.mutation.ClearPrivileged()
	return buo
}

// SetProcessName sets the "process_name" field.
func (buo *BeaconUpdateOne) SetProcessName(s string) *BeaconUpdateOne {
	buo.mutation.SetProcessName(s)
	return buo
}

// SetNillableProcessName sets the "process_name" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableProcessName(s *string) *BeaconUpdateOne {
	if s != nil {
		buo.SetProcessName(*s)
	}
	return buo
}

// ClearProcessName clears the value of the "process_name" field.
func (buo *BeaconUpdateOne) ClearProcessName() *BeaconUpdateOne {
	buo.mutation.ClearProcessName()
	return buo
}

// SetPid sets the "pid" field.
func (buo *BeaconUpdateOne) SetPid(u uint32) *BeaconUpdateOne {
	buo.mutation.ResetPid()
	buo.mutation.SetPid(u)
	return buo
}

// SetNillablePid sets the "pid" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillablePid(u *uint32) *BeaconUpdateOne {
	if u != nil {
		buo.SetPid(*u)
	}
	return buo
}

// AddPid adds u to the "pid" field.
func (buo *BeaconUpdateOne) AddPid(u int32) *BeaconUpdateOne {
	buo.mutation.AddPid(u)
	return buo
}

// ClearPid clears the value of the "pid" field.
func (buo *BeaconUpdateOne) ClearPid() *BeaconUpdateOne {
	buo.mutation.ClearPid()
	return buo
}

// SetArch sets the "arch" field.
func (buo *BeaconUpdateOne) SetArch(da defaults.BeaconArch) *BeaconUpdateOne {
	buo.mutation.SetArch(da)
	return buo
}

// SetNillableArch sets the "arch" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableArch(da *defaults.BeaconArch) *BeaconUpdateOne {
	if da != nil {
		buo.SetArch(*da)
	}
	return buo
}

// SetSleep sets the "sleep" field.
func (buo *BeaconUpdateOne) SetSleep(u uint32) *BeaconUpdateOne {
	buo.mutation.ResetSleep()
	buo.mutation.SetSleep(u)
	return buo
}

// SetNillableSleep sets the "sleep" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableSleep(u *uint32) *BeaconUpdateOne {
	if u != nil {
		buo.SetSleep(*u)
	}
	return buo
}

// AddSleep adds u to the "sleep" field.
func (buo *BeaconUpdateOne) AddSleep(u int32) *BeaconUpdateOne {
	buo.mutation.AddSleep(u)
	return buo
}

// SetJitter sets the "jitter" field.
func (buo *BeaconUpdateOne) SetJitter(u uint8) *BeaconUpdateOne {
	buo.mutation.ResetJitter()
	buo.mutation.SetJitter(u)
	return buo
}

// SetNillableJitter sets the "jitter" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableJitter(u *uint8) *BeaconUpdateOne {
	if u != nil {
		buo.SetJitter(*u)
	}
	return buo
}

// AddJitter adds u to the "jitter" field.
func (buo *BeaconUpdateOne) AddJitter(u int8) *BeaconUpdateOne {
	buo.mutation.AddJitter(u)
	return buo
}

// SetFirst sets the "first" field.
func (buo *BeaconUpdateOne) SetFirst(t time.Time) *BeaconUpdateOne {
	buo.mutation.SetFirst(t)
	return buo
}

// SetNillableFirst sets the "first" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableFirst(t *time.Time) *BeaconUpdateOne {
	if t != nil {
		buo.SetFirst(*t)
	}
	return buo
}

// SetLast sets the "last" field.
func (buo *BeaconUpdateOne) SetLast(t time.Time) *BeaconUpdateOne {
	buo.mutation.SetLast(t)
	return buo
}

// SetNillableLast sets the "last" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableLast(t *time.Time) *BeaconUpdateOne {
	if t != nil {
		buo.SetLast(*t)
	}
	return buo
}

// SetCaps sets the "caps" field.
func (buo *BeaconUpdateOne) SetCaps(u uint32) *BeaconUpdateOne {
	buo.mutation.ResetCaps()
	buo.mutation.SetCaps(u)
	return buo
}

// SetNillableCaps sets the "caps" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableCaps(u *uint32) *BeaconUpdateOne {
	if u != nil {
		buo.SetCaps(*u)
	}
	return buo
}

// AddCaps adds u to the "caps" field.
func (buo *BeaconUpdateOne) AddCaps(u int32) *BeaconUpdateOne {
	buo.mutation.AddCaps(u)
	return buo
}

// SetNote sets the "note" field.
func (buo *BeaconUpdateOne) SetNote(s string) *BeaconUpdateOne {
	buo.mutation.SetNote(s)
	return buo
}

// SetNillableNote sets the "note" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableNote(s *string) *BeaconUpdateOne {
	if s != nil {
		buo.SetNote(*s)
	}
	return buo
}

// ClearNote clears the value of the "note" field.
func (buo *BeaconUpdateOne) ClearNote() *BeaconUpdateOne {
	buo.mutation.ClearNote()
	return buo
}

// SetColor sets the "color" field.
func (buo *BeaconUpdateOne) SetColor(u uint32) *BeaconUpdateOne {
	buo.mutation.ResetColor()
	buo.mutation.SetColor(u)
	return buo
}

// SetNillableColor sets the "color" field if the given value is not nil.
func (buo *BeaconUpdateOne) SetNillableColor(u *uint32) *BeaconUpdateOne {
	if u != nil {
		buo.SetColor(*u)
	}
	return buo
}

// AddColor adds u to the "color" field.
func (buo *BeaconUpdateOne) AddColor(u int32) *BeaconUpdateOne {
	buo.mutation.AddColor(u)
	return buo
}

// SetListener sets the "listener" edge to the Listener entity.
func (buo *BeaconUpdateOne) SetListener(l *Listener) *BeaconUpdateOne {
	return buo.SetListenerID(l.ID)
}

// AddGroupIDs adds the "group" edge to the Group entity by IDs.
func (buo *BeaconUpdateOne) AddGroupIDs(ids ...int) *BeaconUpdateOne {
	buo.mutation.AddGroupIDs(ids...)
	return buo
}

// AddGroup adds the "group" edges to the Group entity.
func (buo *BeaconUpdateOne) AddGroup(g ...*Group) *BeaconUpdateOne {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return buo.AddGroupIDs(ids...)
}

// AddTaskIDs adds the "task" edge to the Task entity by IDs.
func (buo *BeaconUpdateOne) AddTaskIDs(ids ...int) *BeaconUpdateOne {
	buo.mutation.AddTaskIDs(ids...)
	return buo
}

// AddTask adds the "task" edges to the Task entity.
func (buo *BeaconUpdateOne) AddTask(t ...*Task) *BeaconUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return buo.AddTaskIDs(ids...)
}

// Mutation returns the BeaconMutation object of the builder.
func (buo *BeaconUpdateOne) Mutation() *BeaconMutation {
	return buo.mutation
}

// ClearListener clears the "listener" edge to the Listener entity.
func (buo *BeaconUpdateOne) ClearListener() *BeaconUpdateOne {
	buo.mutation.ClearListener()
	return buo
}

// ClearGroup clears all "group" edges to the Group entity.
func (buo *BeaconUpdateOne) ClearGroup() *BeaconUpdateOne {
	buo.mutation.ClearGroup()
	return buo
}

// RemoveGroupIDs removes the "group" edge to Group entities by IDs.
func (buo *BeaconUpdateOne) RemoveGroupIDs(ids ...int) *BeaconUpdateOne {
	buo.mutation.RemoveGroupIDs(ids...)
	return buo
}

// RemoveGroup removes "group" edges to Group entities.
func (buo *BeaconUpdateOne) RemoveGroup(g ...*Group) *BeaconUpdateOne {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return buo.RemoveGroupIDs(ids...)
}

// ClearTask clears all "task" edges to the Task entity.
func (buo *BeaconUpdateOne) ClearTask() *BeaconUpdateOne {
	buo.mutation.ClearTask()
	return buo
}

// RemoveTaskIDs removes the "task" edge to Task entities by IDs.
func (buo *BeaconUpdateOne) RemoveTaskIDs(ids ...int) *BeaconUpdateOne {
	buo.mutation.RemoveTaskIDs(ids...)
	return buo
}

// RemoveTask removes "task" edges to Task entities.
func (buo *BeaconUpdateOne) RemoveTask(t ...*Task) *BeaconUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return buo.RemoveTaskIDs(ids...)
}

// Where appends a list predicates to the BeaconUpdate builder.
func (buo *BeaconUpdateOne) Where(ps ...predicate.Beacon) *BeaconUpdateOne {
	buo.mutation.Where(ps...)
	return buo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (buo *BeaconUpdateOne) Select(field string, fields ...string) *BeaconUpdateOne {
	buo.fields = append([]string{field}, fields...)
	return buo
}

// Save executes the query and returns the updated Beacon entity.
func (buo *BeaconUpdateOne) Save(ctx context.Context) (*Beacon, error) {
	if err := buo.defaults(); err != nil {
		return nil, err
	}
	return withHooks(ctx, buo.sqlSave, buo.mutation, buo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (buo *BeaconUpdateOne) SaveX(ctx context.Context) *Beacon {
	node, err := buo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (buo *BeaconUpdateOne) Exec(ctx context.Context) error {
	_, err := buo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (buo *BeaconUpdateOne) ExecX(ctx context.Context) {
	if err := buo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (buo *BeaconUpdateOne) defaults() error {
	if _, ok := buo.mutation.UpdatedAt(); !ok {
		if beacon.UpdateDefaultUpdatedAt == nil {
			return fmt.Errorf("ent: uninitialized beacon.UpdateDefaultUpdatedAt (forgotten import ent/runtime?)")
		}
		v := beacon.UpdateDefaultUpdatedAt()
		buo.mutation.SetUpdatedAt(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (buo *BeaconUpdateOne) check() error {
	if v, ok := buo.mutation.ExtIP(); ok {
		if err := beacon.ExtIPValidator(v.String()); err != nil {
			return &ValidationError{Name: "ext_ip", err: fmt.Errorf(`ent: validator failed for field "Beacon.ext_ip": %w`, err)}
		}
	}
	if v, ok := buo.mutation.IntIP(); ok {
		if err := beacon.IntIPValidator(v.String()); err != nil {
			return &ValidationError{Name: "int_ip", err: fmt.Errorf(`ent: validator failed for field "Beacon.int_ip": %w`, err)}
		}
	}
	if v, ok := buo.mutation.Os(); ok {
		if err := beacon.OsValidator(v); err != nil {
			return &ValidationError{Name: "os", err: fmt.Errorf(`ent: validator failed for field "Beacon.os": %w`, err)}
		}
	}
	if v, ok := buo.mutation.OsMeta(); ok {
		if err := beacon.OsMetaValidator(v); err != nil {
			return &ValidationError{Name: "os_meta", err: fmt.Errorf(`ent: validator failed for field "Beacon.os_meta": %w`, err)}
		}
	}
	if v, ok := buo.mutation.Hostname(); ok {
		if err := beacon.HostnameValidator(v); err != nil {
			return &ValidationError{Name: "hostname", err: fmt.Errorf(`ent: validator failed for field "Beacon.hostname": %w`, err)}
		}
	}
	if v, ok := buo.mutation.Username(); ok {
		if err := beacon.UsernameValidator(v); err != nil {
			return &ValidationError{Name: "username", err: fmt.Errorf(`ent: validator failed for field "Beacon.username": %w`, err)}
		}
	}
	if v, ok := buo.mutation.Domain(); ok {
		if err := beacon.DomainValidator(v); err != nil {
			return &ValidationError{Name: "domain", err: fmt.Errorf(`ent: validator failed for field "Beacon.domain": %w`, err)}
		}
	}
	if v, ok := buo.mutation.ProcessName(); ok {
		if err := beacon.ProcessNameValidator(v); err != nil {
			return &ValidationError{Name: "process_name", err: fmt.Errorf(`ent: validator failed for field "Beacon.process_name": %w`, err)}
		}
	}
	if v, ok := buo.mutation.Arch(); ok {
		if err := beacon.ArchValidator(v); err != nil {
			return &ValidationError{Name: "arch", err: fmt.Errorf(`ent: validator failed for field "Beacon.arch": %w`, err)}
		}
	}
	if v, ok := buo.mutation.Note(); ok {
		if err := beacon.NoteValidator(v); err != nil {
			return &ValidationError{Name: "note", err: fmt.Errorf(`ent: validator failed for field "Beacon.note": %w`, err)}
		}
	}
	if buo.mutation.ListenerCleared() && len(buo.mutation.ListenerIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Beacon.listener"`)
	}
	return nil
}

func (buo *BeaconUpdateOne) sqlSave(ctx context.Context) (_node *Beacon, err error) {
	if err := buo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(beacon.Table, beacon.Columns, sqlgraph.NewFieldSpec(beacon.FieldID, field.TypeInt))
	id, ok := buo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Beacon.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := buo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, beacon.FieldID)
		for _, f := range fields {
			if !beacon.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != beacon.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := buo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := buo.mutation.UpdatedAt(); ok {
		_spec.SetField(beacon.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := buo.mutation.DeletedAt(); ok {
		_spec.SetField(beacon.FieldDeletedAt, field.TypeTime, value)
	}
	if buo.mutation.DeletedAtCleared() {
		_spec.ClearField(beacon.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := buo.mutation.Bid(); ok {
		_spec.SetField(beacon.FieldBid, field.TypeUint32, value)
	}
	if value, ok := buo.mutation.AddedBid(); ok {
		_spec.AddField(beacon.FieldBid, field.TypeUint32, value)
	}
	if value, ok := buo.mutation.ExtIP(); ok {
		_spec.SetField(beacon.FieldExtIP, field.TypeString, value)
	}
	if buo.mutation.ExtIPCleared() {
		_spec.ClearField(beacon.FieldExtIP, field.TypeString)
	}
	if value, ok := buo.mutation.IntIP(); ok {
		_spec.SetField(beacon.FieldIntIP, field.TypeString, value)
	}
	if buo.mutation.IntIPCleared() {
		_spec.ClearField(beacon.FieldIntIP, field.TypeString)
	}
	if value, ok := buo.mutation.Os(); ok {
		_spec.SetField(beacon.FieldOs, field.TypeEnum, value)
	}
	if value, ok := buo.mutation.OsMeta(); ok {
		_spec.SetField(beacon.FieldOsMeta, field.TypeString, value)
	}
	if buo.mutation.OsMetaCleared() {
		_spec.ClearField(beacon.FieldOsMeta, field.TypeString)
	}
	if value, ok := buo.mutation.Hostname(); ok {
		_spec.SetField(beacon.FieldHostname, field.TypeString, value)
	}
	if buo.mutation.HostnameCleared() {
		_spec.ClearField(beacon.FieldHostname, field.TypeString)
	}
	if value, ok := buo.mutation.Username(); ok {
		_spec.SetField(beacon.FieldUsername, field.TypeString, value)
	}
	if buo.mutation.UsernameCleared() {
		_spec.ClearField(beacon.FieldUsername, field.TypeString)
	}
	if value, ok := buo.mutation.Domain(); ok {
		_spec.SetField(beacon.FieldDomain, field.TypeString, value)
	}
	if buo.mutation.DomainCleared() {
		_spec.ClearField(beacon.FieldDomain, field.TypeString)
	}
	if value, ok := buo.mutation.Privileged(); ok {
		_spec.SetField(beacon.FieldPrivileged, field.TypeBool, value)
	}
	if buo.mutation.PrivilegedCleared() {
		_spec.ClearField(beacon.FieldPrivileged, field.TypeBool)
	}
	if value, ok := buo.mutation.ProcessName(); ok {
		_spec.SetField(beacon.FieldProcessName, field.TypeString, value)
	}
	if buo.mutation.ProcessNameCleared() {
		_spec.ClearField(beacon.FieldProcessName, field.TypeString)
	}
	if value, ok := buo.mutation.Pid(); ok {
		_spec.SetField(beacon.FieldPid, field.TypeUint32, value)
	}
	if value, ok := buo.mutation.AddedPid(); ok {
		_spec.AddField(beacon.FieldPid, field.TypeUint32, value)
	}
	if buo.mutation.PidCleared() {
		_spec.ClearField(beacon.FieldPid, field.TypeUint32)
	}
	if value, ok := buo.mutation.Arch(); ok {
		_spec.SetField(beacon.FieldArch, field.TypeEnum, value)
	}
	if value, ok := buo.mutation.Sleep(); ok {
		_spec.SetField(beacon.FieldSleep, field.TypeUint32, value)
	}
	if value, ok := buo.mutation.AddedSleep(); ok {
		_spec.AddField(beacon.FieldSleep, field.TypeUint32, value)
	}
	if value, ok := buo.mutation.Jitter(); ok {
		_spec.SetField(beacon.FieldJitter, field.TypeUint8, value)
	}
	if value, ok := buo.mutation.AddedJitter(); ok {
		_spec.AddField(beacon.FieldJitter, field.TypeUint8, value)
	}
	if value, ok := buo.mutation.First(); ok {
		_spec.SetField(beacon.FieldFirst, field.TypeTime, value)
	}
	if value, ok := buo.mutation.Last(); ok {
		_spec.SetField(beacon.FieldLast, field.TypeTime, value)
	}
	if value, ok := buo.mutation.Caps(); ok {
		_spec.SetField(beacon.FieldCaps, field.TypeUint32, value)
	}
	if value, ok := buo.mutation.AddedCaps(); ok {
		_spec.AddField(beacon.FieldCaps, field.TypeUint32, value)
	}
	if value, ok := buo.mutation.Note(); ok {
		_spec.SetField(beacon.FieldNote, field.TypeString, value)
	}
	if buo.mutation.NoteCleared() {
		_spec.ClearField(beacon.FieldNote, field.TypeString)
	}
	if value, ok := buo.mutation.Color(); ok {
		_spec.SetField(beacon.FieldColor, field.TypeUint32, value)
	}
	if value, ok := buo.mutation.AddedColor(); ok {
		_spec.AddField(beacon.FieldColor, field.TypeUint32, value)
	}
	if buo.mutation.ListenerCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   beacon.ListenerTable,
			Columns: []string{beacon.ListenerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(listener.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := buo.mutation.ListenerIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   beacon.ListenerTable,
			Columns: []string{beacon.ListenerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(listener.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if buo.mutation.GroupCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.GroupTable,
			Columns: []string{beacon.GroupColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(group.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := buo.mutation.RemovedGroupIDs(); len(nodes) > 0 && !buo.mutation.GroupCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.GroupTable,
			Columns: []string{beacon.GroupColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(group.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := buo.mutation.GroupIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.GroupTable,
			Columns: []string{beacon.GroupColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(group.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if buo.mutation.TaskCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.TaskTable,
			Columns: []string{beacon.TaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := buo.mutation.RemovedTaskIDs(); len(nodes) > 0 && !buo.mutation.TaskCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.TaskTable,
			Columns: []string{beacon.TaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := buo.mutation.TaskIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   beacon.TaskTable,
			Columns: []string{beacon.TaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Beacon{config: buo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, buo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{beacon.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	buo.mutation.done = true
	return _node, nil
}
